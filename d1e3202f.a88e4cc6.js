(window.webpackJsonp=window.webpackJsonp||[]).push([[44],{111:function(e,t,n){"use strict";n.r(t),n.d(t,"frontMatter",(function(){return i})),n.d(t,"metadata",(function(){return s})),n.d(t,"toc",(function(){return c})),n.d(t,"default",(function(){return b}));var a=n(3),o=n(7),r=(n(0),n(123)),i={slug:"zio-streams-jms",title:"ZIO Streams and JMS",tags:["ZIO","Streams","JMS"],author:"Andreas Gies",author_url:"https://github.com/atooni"},s={permalink:"/blended-zio/blog/zio-streams-jms",source:"@site/blog/2020-10-27-ZIOJms.md",description:"In this article we are going to explore a bit of the ZIO streams API and how it can be used to talk to a JMS broker. The ZIO web site and awesome-zio have a lot of very good articles and talks on ZIO streams covering the basics, so I won't repeat those here.",date:"2020-10-27T00:00:00.000Z",tags:[{label:"ZIO",permalink:"/blended-zio/blog/tags/zio"},{label:"Streams",permalink:"/blended-zio/blog/tags/streams"},{label:"JMS",permalink:"/blended-zio/blog/tags/jms"}],title:"ZIO Streams and JMS",truncated:!0,prevItem:{title:"Autorecovery for (JMS) Streams",permalink:"/blended-zio/blog/zio-streams-autorecover"},nextItem:{title:"Use ZIO Logging",permalink:"/blended-zio/blog/zio-logging"}},c=[{value:"What we want to achieve",id:"what-we-want-to-achieve",children:[]},{value:"Constructing the Environment",id:"constructing-the-environment",children:[]},{value:"Sending messages",id:"sending-messages",children:[]},{value:"Receiving messages",id:"receiving-messages",children:[]},{value:"Next steps",id:"next-steps",children:[]},{value:"Conclusion",id:"conclusion",children:[]}],l={toc:c};function b(e){var t=e.components,n=Object(o.a)(e,["components"]);return Object(r.b)("wrapper",Object(a.a)({},l,n,{components:t,mdxType:"MDXLayout"}),Object(r.b)("p",null,"In this article we are going to explore a bit of the ZIO streams API and how it can be used to talk to a JMS broker. The ",Object(r.b)("a",Object(a.a)({parentName:"p"},{href:"https://zio.dev/docs/resources/resources"}),"ZIO web site")," and ",Object(r.b)("a",Object(a.a)({parentName:"p"},{href:"https://github.com/aparo/awesome-zio"}),"awesome-zio")," have a lot of very good articles and talks on ZIO streams covering the basics, so I won't repeat those here."),Object(r.b)("p",null,"For this article I have used an embedded ",Object(r.b)("a",Object(a.a)({parentName:"p"},{href:"https://activemq.apache.org/"}),"ActiveMQ")," messaging broker, but the code makes no assumptions about the underlying JMS provider. Usually the JMS broker would run externally and we would use a provider specific connection factory to connect to it."),Object(r.b)("div",{className:"admonition admonition-info alert alert--info"},Object(r.b)("div",Object(a.a)({parentName:"div"},{className:"admonition-heading"}),Object(r.b)("h5",{parentName:"div"},Object(r.b)("span",Object(a.a)({parentName:"h5"},{className:"admonition-icon"}),Object(r.b)("svg",Object(a.a)({parentName:"span"},{xmlns:"http://www.w3.org/2000/svg",width:"14",height:"16",viewBox:"0 0 14 16"}),Object(r.b)("path",Object(a.a)({parentName:"svg"},{fillRule:"evenodd",d:"M7 2.3c3.14 0 5.7 2.56 5.7 5.7s-2.56 5.7-5.7 5.7A5.71 5.71 0 0 1 1.3 8c0-3.14 2.56-5.7 5.7-5.7zM7 1C3.14 1 0 4.14 0 8s3.14 7 7 7 7-3.14 7-7-3.14-7-7-7zm1 3H6v5h2V4zm0 6H6v2h2v-2z"})))),"info")),Object(r.b)("div",Object(a.a)({parentName:"div"},{className:"admonition-content"}),Object(r.b)("p",{parentName:"div"},"The complete source code used in this article can be found on ",Object(r.b)("a",Object(a.a)({parentName:"p"},{href:"https://github.com/blended-zio/blended-zio/tree/main/blended.zio.streams"}),"github")))),Object(r.b)("h2",{id:"what-we-want-to-achieve"},"What we want to achieve"),Object(r.b)("p",null,"Let's start by considering what a simple program sending and receiving messages from an ActiveMQ broker would look like. That program should be runnable as normal ZIO app:"),Object(r.b)("pre",null,Object(r.b)("code",Object(a.a)({parentName:"pre"},{className:"language-scala"}),'  private val program =\n    for {\n      _      <- putStrLn("Starting JMS Broker") *> ZIO.service[BrokerService]\n      conMgr <- ZIO.service[ZIOJmsConnectionManager.Service]\n      _      <- (for {\n                  con <- conMgr.connect(cf, "sample")\n                  _   <- conMgr.reconnect(con, Some(new Exception("Boom"))).schedule(Schedule.duration(10.seconds)).fork\n                  _   <- for {\n                           c <- consumer(con).fork\n                           p <- producer(con).fork\n                           _ <- c.join\n                           _ <- p.join\n                         } yield ()\n                } yield ())\n    } yield ()\n')),Object(r.b)("p",null,"We can see from ",Object(r.b)("inlineCode",{parentName:"p"},"program"),"'s type that besides the ZIO environment ",Object(r.b)("inlineCode",{parentName:"p"},"ZEnv")," we will need an ActiveMQ message broker and also the ",Object(r.b)("a",Object(a.a)({parentName:"p"},{href:"https://zio.github.io/zio-logging/"}),"ZIO logging API")," to execute the program. With those requirements the program is fairly straightforward:"),Object(r.b)("ol",null,Object(r.b)("li",{parentName:"ol"},"aquire the message broker from the environment"),Object(r.b)("li",{parentName:"ol"},"create a connection factory to talk to the broker just started"),Object(r.b)("li",{parentName:"ol"},"create a fiber that simply sits in the background for 10 seconds"),Object(r.b)("li",{parentName:"ol"},"use the connection factory to establish a JMS connection"),Object(r.b)("li",{parentName:"ol"},"use the connection to kick off a sender and receiver"),Object(r.b)("li",{parentName:"ol"},"join with the timed fiber to interrupt the sender and receiver"),Object(r.b)("li",{parentName:"ol"},"clean up the connection")),Object(r.b)("div",{className:"admonition admonition-info alert alert--info"},Object(r.b)("div",Object(a.a)({parentName:"div"},{className:"admonition-heading"}),Object(r.b)("h5",{parentName:"div"},Object(r.b)("span",Object(a.a)({parentName:"h5"},{className:"admonition-icon"}),Object(r.b)("svg",Object(a.a)({parentName:"span"},{xmlns:"http://www.w3.org/2000/svg",width:"14",height:"16",viewBox:"0 0 14 16"}),Object(r.b)("path",Object(a.a)({parentName:"svg"},{fillRule:"evenodd",d:"M7 2.3c3.14 0 5.7 2.56 5.7 5.7s-2.56 5.7-5.7 5.7A5.71 5.71 0 0 1 1.3 8c0-3.14 2.56-5.7 5.7-5.7zM7 1C3.14 1 0 4.14 0 8s3.14 7 7 7 7-3.14 7-7-3.14-7-7-7zm1 3H6v5h2V4zm0 6H6v2h2v-2z"})))),"info")),Object(r.b)("div",Object(a.a)({parentName:"div"},{className:"admonition-content"}),Object(r.b)("p",{parentName:"div"},"The sample program has a scheduled ",Object(r.b)("inlineCode",{parentName:"p"},"reconnect")," after 10 seconds. This will cause the execution to fail with an exception because the underlying streams terminate with a ",Object(r.b)("inlineCode",{parentName:"p"},"JMSException"),". In one of the next articles I will get into stream recovery."))),Object(r.b)("p",null,"We will dive into the various steps throughout the remainder of this article to see how ZIO is helping to provide a smooth access to JMS. First, let's see how we can run the program above:"),Object(r.b)("pre",null,Object(r.b)("code",Object(a.a)({parentName:"pre"},{className:"language-scala"}),"  override def run(args: List[String]): ZIO[ZEnv, Nothing, ExitCode] = program\n    .provideCustomLayer(combinedEnv)\n    .catchAllCause(c => putStrLn(c.prettyPrint))\n    .exitCode\n")),Object(r.b)("p",null,"As we can see, we need to provide the environment with all required services, so that the ",Object(r.b)("inlineCode",{parentName:"p"},"program")," can actually execute."),Object(r.b)("h2",{id:"constructing-the-environment"},"Constructing the Environment"),Object(r.b)("p",null,"First, we create a layer which consist of the standard ZIO environment enriched with the Slf4j implementation of the ",Object(r.b)("inlineCode",{parentName:"p"},"Logging")," service. This layer is required by the ActiveMQ service implementation and also by the program itself."),Object(r.b)("p",null,"Next we create the ActiveMQ service using vertical composition with the ",Object(r.b)("inlineCode",{parentName:"p"},"logEnv")," and also an instance of a ",Object(r.b)("inlineCode",{parentName:"p"},"ZIOJmsConnectionManager")," which we stick into the environment as well."),Object(r.b)("p",null,"Finally we can create the ",Object(r.b)("inlineCode",{parentName:"p"},"combinedEnv")," using horizontal composition of the logging, the broker layer and the connection manager layer."),Object(r.b)("p",null,"The resulting environments contains everything to run our program."),Object(r.b)("pre",null,Object(r.b)("code",Object(a.a)({parentName:"pre"},{className:"language-scala"}),'  private val logEnv: ZLayer[Any, Nothing, ZEnv with Logging] =\n    ZEnv.live ++ Slf4jLogger.make((_, message) => message)\n\n  private val brokerEnv: ZLayer[Any, Throwable, AMQBroker.AMQBroker] =\n    logEnv >>> AMQBroker.simple("simple")\n\n  private val mgrEnv = ZIOJmsConnectionManager.Service.make\n\n  private val combinedEnv =\n    logEnv ++ brokerEnv ++ mgrEnv\n')),Object(r.b)("p",null,"For reference, the Active MQ broker service is ",Object(r.b)("a",Object(a.a)({parentName:"p"},{href:"https://github.com/blended-zio/blended-zio-activemq/blob/main/blended-zio-activemq/src/main/scala/blended/zio/activemq/AMQBroker.scala"}),"here"),"."),Object(r.b)("h2",{id:"sending-messages"},"Sending messages"),Object(r.b)("p",null,"To have some data travelling the message broker, let's start by creating a plain ZIO stream, which emits a String element every half second or so. Each element is simply the current time formatted using a ",Object(r.b)("inlineCode",{parentName:"p"},"SimpleDateFormat"),"."),Object(r.b)("pre",null,Object(r.b)("code",Object(a.a)({parentName:"pre"},{className:"language-scala"}),"  private val stream: ZStream[ZEnv, Nothing, String] = ZStream\n    .fromSchedule(Schedule.spaced(500.millis).jittered)\n    .mapM(_ =>\n      currentTime(TimeUnit.MILLISECONDS)\n        .map(sdf.format)\n    )\n")),Object(r.b)("p",null,"Now we want to send all these Strings to JMS and later on receive them."),Object(r.b)("pre",null,Object(r.b)("code",Object(a.a)({parentName:"pre"},{className:"language-scala"}),"  private def producer(con: JmsConnection) =\n    createSession(con).use(session => createProducer(session).use(prod => stream.run(jmsSink(prod, testDest))))\n")),Object(r.b)("p",null,"The send is broken down into these steps:"),Object(r.b)("ol",null,Object(r.b)("li",{parentName:"ol"},"create the JMS session"),Object(r.b)("li",{parentName:"ol"},"create the JMS MessageProducer"),Object(r.b)("li",{parentName:"ol"},"use the producer to create a ZIO Sink"),Object(r.b)("li",{parentName:"ol"},"run the stream with the sink, so that the generated messages aresent to JMS")),Object(r.b)("div",{className:"admonition admonition-info alert alert--info"},Object(r.b)("div",Object(a.a)({parentName:"div"},{className:"admonition-heading"}),Object(r.b)("h5",{parentName:"div"},Object(r.b)("span",Object(a.a)({parentName:"h5"},{className:"admonition-icon"}),Object(r.b)("svg",Object(a.a)({parentName:"span"},{xmlns:"http://www.w3.org/2000/svg",width:"14",height:"16",viewBox:"0 0 14 16"}),Object(r.b)("path",Object(a.a)({parentName:"svg"},{fillRule:"evenodd",d:"M7 2.3c3.14 0 5.7 2.56 5.7 5.7s-2.56 5.7-5.7 5.7A5.71 5.71 0 0 1 1.3 8c0-3.14 2.56-5.7 5.7-5.7zM7 1C3.14 1 0 4.14 0 8s3.14 7 7 7 7-3.14 7-7-3.14-7-7-7zm1 3H6v5h2V4zm0 6H6v2h2v-2z"})))),"info")),Object(r.b)("div",Object(a.a)({parentName:"div"},{className:"admonition-content"}),Object(r.b)("p",{parentName:"div"},"Within the JMS API we use a number of ",Object(r.b)("a",Object(a.a)({parentName:"p"},{href:"https://github.com/blended-zio/blended-zio/blob/main/blended.zio.streams/src/main/scala/blended/zio/streams/jms/jmsobjects.scala"}),"case classes")," that are simple wrappers around the underlying JMS classes. Essentially these case classes contain some additional information besides the original object. For one, we keep a reference of the instance that was used as a factory. I.e. the ",Object(r.b)("inlineCode",{parentName:"p"},"JmsSession")," has a reference to the connection it belongs to and a ",Object(r.b)("inlineCode",{parentName:"p"},"JmsConsumer")," a reference to the ",Object(r.b)("inlineCode",{parentName:"p"},"JmsSession")," it was created for."),Object(r.b)("p",{parentName:"div"},"Besides that all classes contain a human readable identifier, which is mainly used to produce a more readable log."))),Object(r.b)("p",null,"Having this in mind, we create a named JMS session as a ",Object(r.b)("inlineCode",{parentName:"p"},"ZManaged"),", so that ZIO takes care of closing the session after it has been used. Within the session we create a ",Object(r.b)("inlineCode",{parentName:"p"},"JmsProducer"),", which is again a ",Object(r.b)("inlineCode",{parentName:"p"},"ZManaged"),"."),Object(r.b)("p",null,"Note, that the producer does not actually ",Object(r.b)("em",{parentName:"p"},"produce")," the messages in the sense of JMS - it just has all the information to do so."),Object(r.b)("p",null,"So, let's have a look how we can define an effect using the poducer to actually send a message:"),Object(r.b)("pre",null,Object(r.b)("code",Object(a.a)({parentName:"pre"},{className:"language-scala"}),'  def send(\n    text: String,\n    prod: JmsProducer,\n    dest: JmsDestination\n  ) = (for {\n    msg <- effectBlocking(prod.session.session.createTextMessage(text))\n    d   <- dest.create(prod.session)\n    _   <- effectBlocking(prod.producer.send(d, msg))\n    _   <- log.debug(s"Message [$text] sent successfully with [$prod] to [${dest.asString}]")\n  } yield ()).flatMapError { t =>\n    log.warn(s"Error sending message with [$prod] to [$dest]: [${t.getMessage()}]") *> ZIO.succeed(t)\n  }.refineOrDie { case t: JMSException => t }\n')),Object(r.b)("ol",null,Object(r.b)("li",{parentName:"ol"},"use the producer's session to create the JMS ",Object(r.b)("inlineCode",{parentName:"li"},"Message")," object"),Object(r.b)("li",{parentName:"ol"},"use the producer's session to create the JMS ",Object(r.b)("inlineCode",{parentName:"li"},"Destination")," object"),Object(r.b)("li",{parentName:"ol"},"perform the JMS send"),Object(r.b)("li",{parentName:"ol"},"record the send in the log")),Object(r.b)("p",null,"Now that we have the effect sending a single message, we can easily create a sink. The ",Object(r.b)("inlineCode",{parentName:"p"},"ZSink")," object in the ZIO streams API has a ",Object(r.b)("inlineCode",{parentName:"p"},"foreach")," method, which allows us to create a sink from an effect:"),Object(r.b)("pre",null,Object(r.b)("code",Object(a.a)({parentName:"pre"},{className:"language-scala"}),"// in ZSink:\ndef foreach[R, E, I](f: I => ZIO[R, E, Any]): ZSink[R, E, I, I, Unit]\n")),Object(r.b)("p",null,"Let's take a moment to digest the signature: ",Object(r.b)("inlineCode",{parentName:"p"},"R")," and ",Object(r.b)("inlineCode",{parentName:"p"},"E")," is the usual type magic within ZIO to describe the environment required for the sink and the errors it may produce. ",Object(r.b)("inlineCode",{parentName:"p"},"Unit")," in that case means that the final result after running a Stream with this Sink is ",Object(r.b)("inlineCode",{parentName:"p"},"Unit"),". In other words, the Stream is just run for the effect passed in as a parameter."),Object(r.b)("p",null,"The function provided needs to create an effect for each element of type ",Object(r.b)("inlineCode",{parentName:"p"},"I"),"."),Object(r.b)("p",null,"In our case we already have the effect, which is the ",Object(r.b)("inlineCode",{parentName:"p"},"send")," method above, so we can define our sink as"),Object(r.b)("pre",null,Object(r.b)("code",Object(a.a)({parentName:"pre"},{className:"language-scala"}),"  def jmsSink(\n    prod: JmsProducer,\n    dest: JmsDestination\n  ) =\n    ZSink.foreach[ZEnv with Logging with ZIOJmsConnectionManager, JMSException, String](s => send(s, prod, dest))\n")),Object(r.b)("h2",{id:"receiving-messages"},"Receiving messages"),Object(r.b)("p",null,"Now let's understand the ",Object(r.b)("inlineCode",{parentName:"p"},"consumer")," of our program:"),Object(r.b)("pre",null,Object(r.b)("code",Object(a.a)({parentName:"pre"},{className:"language-scala"}),"  private def consumer(con: JmsConnection) =\n    createSession(con).use { session =>\n      createConsumer(session, testDest).use { cons =>\n        jmsStream(cons).collect { case m: TextMessage => m.getText() }\n          .foreach(s => putStrLn(s))\n      }\n    }\n")),Object(r.b)("p",null,"Again, we need to create a ",Object(r.b)("inlineCode",{parentName:"p"},"JmsSession"),", but this time we use it to create a ",Object(r.b)("inlineCode",{parentName:"p"},"JmsConsumer")," for the given ",Object(r.b)("inlineCode",{parentName:"p"},"JmsDestination"),".\nWe then use the created consumer to create a ",Object(r.b)("inlineCode",{parentName:"p"},"ZStream[R, E, Message]"),", in other words a plain ",Object(r.b)("inlineCode",{parentName:"p"},"ZStream")," of JMS ",Object(r.b)("inlineCode",{parentName:"p"},"Message")," objects. From that stream we collect all ",Object(r.b)("inlineCode",{parentName:"p"},"TextMessage")," instances, get the ",Object(r.b)("inlineCode",{parentName:"p"},"String")," body of those and print that to the console."),Object(r.b)("p",null,"Creating the stream is again amazingly simple with the ZIO streams API:"),Object(r.b)("pre",null,Object(r.b)("code",Object(a.a)({parentName:"pre"},{className:"language-scala"}),"  def jmsStream(cons: JmsConsumer) =\n    ZStream.repeatEffect(receive(cons)).collect { case Some(s) => s }\n")),Object(r.b)("p",null,"We repeat an effect producing optional ",Object(r.b)("inlineCode",{parentName:"p"},"Message")," objects (optional because the underlying receive yields ",Object(r.b)("inlineCode",{parentName:"p"},"None")," if no message is available for the consumer). As we are only interested in the actual messages, we collect only the results actually having a ",Object(r.b)("inlineCode",{parentName:"p"},"Message"),"."),Object(r.b)("p",null,"The actual consume is simply a wrapper around the JMS API with some logging:"),Object(r.b)("pre",null,Object(r.b)("code",Object(a.a)({parentName:"pre"},{className:"language-scala"}),'  def receive(cons: JmsConsumer) = (for {\n    msg <- effectBlocking(Option(cons.consumer.receiveNoWait()))\n    _   <- if (msg.isDefined) log.debug(s"Received [$msg] with [$cons]") else ZIO.unit\n  } yield msg).flatMapError { t =>\n    log.warn(s"Error receiving message with [$cons] : [${t.getMessage()}]") *> ZIO.succeed(t)\n  }.refineOrDie { case t: JMSException => t }\n')),Object(r.b)("h2",{id:"next-steps"},"Next steps"),Object(r.b)("p",null,"I have not elaborated too much on the underlying ",Object(r.b)("inlineCode",{parentName:"p"},"ZIOJmsConnectionManager"),". Essentially this is a map to hold named connection factories. At the moment the connection manager guarantees that for a given id only one physical JMS connection is created. Also, the connection manager will provide automated reconnects and connection monitoring, which we will look at in later articles."),Object(r.b)("p",null,"Next I will explore how to enhance the demo program with some resilience. The idea here is to create ",Object(r.b)("em",{parentName:"p"},"self healing")," streams that would automatically reconnect after a connection has been lost."),Object(r.b)("p",null,"For now I have just used Strings as message objects; this will be enhanced to more flexible and useful messages."),Object(r.b)("h2",{id:"conclusion"},"Conclusion"),Object(r.b)("p",null,"With ZIO it is very straight forward to break down a given problem into smaller pieces and then use those as building blocks for the solution. The challenge for developer like me is to get the head around the signatures and how all the types play together."),Object(r.b)("p",null,"For example, building the environment took me a couple of hours to get it right. One has to take the time to read and understand the compiler errors. In the end I found that these errors pretty much tell me what I need to put together in terms of hirzontal and vertical composition to get it right."),Object(r.b)("p",null,"The first steps in some areas of ZIO require quite a bit of code study. Given that ZIO is just beyond it's first official release, the documentation and other resources are plenty, but scattered araound talks and blogs. The ",Object(r.b)("a",Object(a.a)({parentName:"p"},{href:"https://www.zionomicon.com/"}),"upcoming book by John De Goes and Adam Fraser")," adresses a lot of that and already has a lot of content in it's alpha version."),Object(r.b)("p",null,"Even if it means stating the obvious: Also when you work with a more sophisticated API in ZIO in the inner layers you are going to find ZIO effects which you then combine into something else - in our case create ",Object(r.b)("inlineCode",{parentName:"p"},"ZStream")," and ",Object(r.b)("inlineCode",{parentName:"p"},"ZSink")," from plain ZIO's and then have the entire ZStream magic at the tip of your fingers to manipulate JMS streams."))}b.isMDXComponent=!0},123:function(e,t,n){"use strict";n.d(t,"a",(function(){return m})),n.d(t,"b",(function(){return h}));var a=n(0),o=n.n(a);function r(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function i(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function s(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?i(Object(n),!0).forEach((function(t){r(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):i(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function c(e,t){if(null==e)return{};var n,a,o=function(e,t){if(null==e)return{};var n,a,o={},r=Object.keys(e);for(a=0;a<r.length;a++)n=r[a],t.indexOf(n)>=0||(o[n]=e[n]);return o}(e,t);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);for(a=0;a<r.length;a++)n=r[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(o[n]=e[n])}return o}var l=o.a.createContext({}),b=function(e){var t=o.a.useContext(l),n=t;return e&&(n="function"==typeof e?e(t):s(s({},t),e)),n},m=function(e){var t=b(e.components);return o.a.createElement(l.Provider,{value:t},e.children)},p={inlineCode:"code",wrapper:function(e){var t=e.children;return o.a.createElement(o.a.Fragment,{},t)}},d=o.a.forwardRef((function(e,t){var n=e.components,a=e.mdxType,r=e.originalType,i=e.parentName,l=c(e,["components","mdxType","originalType","parentName"]),m=b(n),d=a,h=m["".concat(i,".").concat(d)]||m[d]||p[d]||r;return n?o.a.createElement(h,s(s({ref:t},l),{},{components:n})):o.a.createElement(h,s({ref:t},l))}));function h(e,t){var n=arguments,a=t&&t.mdxType;if("string"==typeof e||a){var r=n.length,i=new Array(r);i[0]=d;var s={};for(var c in t)hasOwnProperty.call(t,c)&&(s[c]=t[c]);s.originalType=e,s.mdxType="string"==typeof e?e:a,i[1]=s;for(var l=2;l<r;l++)i[l]=n[l];return o.a.createElement.apply(null,i)}return o.a.createElement.apply(null,n)}d.displayName="MDXCreateElement"}}]);