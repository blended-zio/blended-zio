(window.webpackJsonp=window.webpackJsonp||[]).push([[41],{108:function(e,t,n){"use strict";n.r(t),n.d(t,"frontMatter",(function(){return c})),n.d(t,"metadata",(function(){return o})),n.d(t,"toc",(function(){return s})),n.d(t,"default",(function(){return d}));var r=n(3),i=n(7),a=(n(0),n(113)),c={id:"servicemetrics",title:"Service Metrics"},o={unversionedId:"jmx/servicemetrics",id:"jmx/servicemetrics",isDocsHomePage:!1,title:"Service Metrics",description:"The implementation of the ZIO version starts with defining an interface that resembles the operations which are hidden behind the actor based implementation of Blended 3. Essentially, the straight forward approach is to look at the messages the actor currently understands and translate them into corresponding methods on the interface.",source:"@site/docs/jmx/ServiceMetrics.md",slug:"/jmx/servicemetrics",permalink:"/blended-zio/docs/jmx/servicemetrics",version:"current",sidebar:"someSidebar",previous:{title:"MBean Publisher",permalink:"/blended-zio/docs/jmx/mbeanpublisher"},next:{title:"Blended ZIO Streams",permalink:"/blended-zio/docs/streams/index"}},s=[{value:"Implementation notes",id:"implementation-notes",children:[]},{value:"Testing",id:"testing",children:[]}],l={toc:s};function d(e){var t=e.components,n=Object(i.a)(e,["components"]);return Object(a.b)("wrapper",Object(r.a)({},l,n,{components:t,mdxType:"MDXLayout"}),Object(a.b)("p",null,"The implementation of the ZIO version starts with defining an interface that resembles the operations which are ",Object(a.b)("em",{parentName:"p"},"hidden")," behind the actor based implementation of ",Object(a.b)("em",{parentName:"p"},"Blended 3"),". Essentially, the straight forward approach is to look at the messages the actor currently understands and translate them into corresponding methods on the interface."),Object(a.b)("p",null,"The actor currently understands 3 messages:"),Object(a.b)("ul",null,Object(a.b)("li",{parentName:"ul"},"start service invocation"),Object(a.b)("li",{parentName:"ul"},"complete invocation with success"),Object(a.b)("li",{parentName:"ul"},"complete invocation with error")),Object(a.b)("p",null,"In addition to this we would like to retrieve the current list of active invocations and also the current collected summaries."),Object(a.b)("p",null,"This leads to the following interface definition:"),Object(a.b)("pre",null,Object(a.b)("code",Object(r.a)({parentName:"pre"},{className:"language-scala"}),"  trait Service {\n\n    /**\n     * Start to track a service invocation for a given start event.\n     * If a tracker for that id is still active, a [[ServiceMetricsException]] will be returned.\n     * Otherwise, an updated ServiceTrackingEntry will be returned.\n     * @param start The start event containing the details of the service invocation to be tracked\n     */\n    def start(start: ServiceInvocationStarted): ZIO[Any, ServiceMetricsException, ServiceTrackingEntry]\n\n    /**\n     * Signal the successful completion of a service invocation. The invocation is referenced by\n     * the id of a corresponding call to [[start]]. If the invocation cannot be found, a\n     * [[ServiceMetricsException]] will be returned\n     * @param s The completion event for the service invocation\n     */\n    def complete(s: ServiceInvocationCompleted): ZIO[Any, ServiceMetricsException, ServiceTrackingEntry]\n\n    /**\n     * Signal the successful completion of a service invocation. The invocation is referenced by\n     * the id of a corresponding call to [[start]]. If the invocation cannot be found, a\n     * [[ServiceMetricsException]] will be returned.\n     * @param f The completion event for the service invocation\n     */\n    def failed(f: ServiceInvocationFailed): ZIO[Any, ServiceMetricsException, ServiceTrackingEntry]\n\n    /**\n     * Get the list of service invocation ids which are currently active.\n     */\n    def active: ZIO[Any, Nothing, List[String]]\n\n    /**\n     * Get the current Map of summaries recorded by the Service tracker\n     */\n    def summaries: ZIO[Any, Nothing, Map[String, ServiceTrackingEntry]]\n  }\n")),Object(a.b)("p",null,"Note, that all methods on the interface return ZIO effects."),Object(a.b)("h2",{id:"implementation-notes"},"Implementation notes"),Object(a.b)("p",null,"The implementation needs to maintain a list currently active of service invocation invocations, so that we can properly close them with a failed or completed event. Furthermore, we need to keep track of the invocation summaries so that we can keep track of the grouped invocations statistics."),Object(a.b)("p",null,"Inspired by ",Object(a.b)("a",Object(r.a)({parentName:"p"},{href:"https://scalac.io/how-to-write-a-completely-lock-free-concurrent-lru-cache-with-zio-stm/"}),"this article")," about implementing a concurrent LRU cache we have decided to implement a ConcurrentServiceTracker using STM References under the covers:"),Object(a.b)("pre",null,Object(a.b)("code",Object(r.a)({parentName:"pre"},{className:"language-scala"}),"final class ConcurrentInvocationTracker private (\n  val running: TMap[String, ServiceInvocationStarted],\n  val summary: TMap[String, ServiceTrackingEntry]\n) { self =>\n")),Object(a.b)("p",null,"First of all we need a couple of helpers helping us to manipulate the two maps. The names of the helper functions speak for themselves and all of them use STM under the covers, so that we can compose them to implement the actual business functions and finally call commit in order to end up with a ZIO effect as result."),Object(a.b)("pre",null,Object(a.b)("code",Object(r.a)({parentName:"pre"},{className:"language-scala"}),"  private val updStarted: ServiceTrackingEntry => ServiceTrackingEntry =\n    e => e.copy(inflight = e.inflight + 1)\n\n  private val updFailed: Long => ServiceTrackingEntry => ServiceTrackingEntry = started =>\n    orig =>\n      orig.copy(\n        lastFailed = Some(System.currentTimeMillis()),\n        failed = orig.failed.record(System.currentTimeMillis() - started),\n        inflight = orig.inflight - 1\n      )\n\n  private val updCompleted: Long => ServiceTrackingEntry => ServiceTrackingEntry = started =>\n    orig =>\n      orig.copy(\n        success = orig.success.record(System.currentTimeMillis() - started),\n        inflight = orig.inflight - 1\n      )\n\n  private def getExistingSummary(sumId: String): STM[ServiceMetricsException, ServiceTrackingEntry] =\n    STM.require(new ServiceSummaryNotFoundException(sumId))(self.summary.get(sumId))\n\n  private def getExistingActive(id: String): STM[ServiceMetricsException, ServiceInvocationStarted] =\n    STM.require(new ServiceInvocationNotFoundException(id))(self.running.get(id))\n\n  private def addSummary(evt: ServiceInvocationStarted): STM[Nothing, ServiceTrackingEntry] = for {\n    entry <- STM.succeed(ServiceTrackingEntry(evt.summarizeId))\n    _     <- self.summary.put(evt.summarizeId, entry)\n  } yield (entry)\n\n  private def getOrCreateSummary(evt: ServiceInvocationStarted): STM[Nothing, ServiceTrackingEntry] =\n    self.summary.get(evt.summarizeId).flatMap {\n      case Some(e) => STM.succeed(e)\n      case None    => addSummary(evt)\n    }\n")),Object(a.b)("p",null,"Within the implementation the ",Object(a.b)("inlineCode",{parentName:"p"},"update"),"method is responsible for recording the completion or failure for a given invocation id. Therefore we need to determine the currently active entry from our active map and also the existing summary. Note that if everything works as designed, the summary mst already exist at this point in time. However, either of these calls may fail with a ServiceMetricsException, which is reflected in the method signature."),Object(a.b)("p",null,"Once we have looked up the entries, we can simply perform the required update and we are done."),Object(a.b)("pre",null,Object(a.b)("code",Object(r.a)({parentName:"pre"},{className:"language-scala"}),"  private def update(id: String, success: Boolean): ZIO[Any, ServiceMetricsException, ServiceTrackingEntry] = (for {\n    act   <- getExistingActive(id)\n    sumId  = act.summarizeId\n    entry <- getExistingSummary(sumId)\n    upd    = if (success) updCompleted(act.timestamp)(entry) else updFailed(act.timestamp)(entry)\n    _     <- self.summary.put(sumId, upd)\n    _     <- self.running.delete(id)\n  } yield (upd)).commit\n")),Object(a.b)("p",null,"The ",Object(a.b)("inlineCode",{parentName:"p"},"start")," method is very similar. We are using ",Object(a.b)("inlineCode",{parentName:"p"},"getExistingActive(evt.id).flip"),", so that having an already defined entry for the given id will be considered an exception. Also, in this case we are using ",Object(a.b)("inlineCode",{parentName:"p"},"getOrCreateSummary(evt)")," to ensure that the summary map definitely has an entry."),Object(a.b)("p",null,"Finally, we are using ",Object(a.b)("inlineCode",{parentName:"p"},"mapError")," to create the proper exception indicating the a service with the same id was already active."),Object(a.b)("pre",null,Object(a.b)("code",Object(r.a)({parentName:"pre"},{className:"language-scala"}),"  def start(evt: ServiceInvocationStarted): ZIO[Any, ServiceMetricsException, ServiceTrackingEntry] = (for {\n    // Using the flip will turn an existing invocation into the error type, so that we can handle that\n    // at the end with mapError\n    _     <- getExistingActive(evt.id).flip\n    _     <- self.running.put(evt.id, evt)\n    // make sure we do have a summary entry in our summary map\n    entry <- getOrCreateSummary(evt)\n    // Record the service start\n    upd    = updStarted(entry)\n    _     <- self.summary.put(evt.summarizeId, upd)\n  } yield (upd)).commit.mapError(_ => new ServiceAlreadyStartedException(evt))\n")),Object(a.b)("h2",{id:"testing"},"Testing"),Object(a.b)("p",null,"Testing is done with ",Object(a.b)("a",Object(r.a)({parentName:"p"},{href:"https://zio.dev/docs/howto/howto_test_effects"}),"zio-test")," and is fairly straight forward. The tests provide the ",Object(a.b)("inlineCode",{parentName:"p"},"live")," service via ",Object(a.b)("inlineCode",{parentName:"p"},"ZLayer")," and then use the interface methods to call the service and verify the result with assertions."),Object(a.b)("p",null,"For example, the test to verify that a successful service completion is implemented as follows:"),Object(a.b)("pre",null,Object(a.b)("code",Object(r.a)({parentName:"pre"},{className:"language-scala"}),'  private val recordComplete = testM("record a service completion correctly") {\n    for {\n      tracker <- ZIO.service[ServiceMetrics.Service]\n      s       <- start\n      c       <- completed(s)\n      old     <- tracker.summaries\n      e       <- ZIO.effectTotal(old.getOrElse(s.summarizeId, ServiceTrackingEntry(s.summarizeId)))\n      _       <- tracker.start(s)\n      _       <- tracker.complete(c)\n      sum     <- tracker.summaries\n    } yield assert(sum(s.summarizeId).success.count)(isGreaterThanEqualTo(e.success.count))\n  }\n')))}d.isMDXComponent=!0},113:function(e,t,n){"use strict";n.d(t,"a",(function(){return m})),n.d(t,"b",(function(){return v}));var r=n(0),i=n.n(r);function a(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function c(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);t&&(r=r.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,r)}return n}function o(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?c(Object(n),!0).forEach((function(t){a(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):c(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function s(e,t){if(null==e)return{};var n,r,i=function(e,t){if(null==e)return{};var n,r,i={},a=Object.keys(e);for(r=0;r<a.length;r++)n=a[r],t.indexOf(n)>=0||(i[n]=e[n]);return i}(e,t);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);for(r=0;r<a.length;r++)n=a[r],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(i[n]=e[n])}return i}var l=i.a.createContext({}),d=function(e){var t=i.a.useContext(l),n=t;return e&&(n="function"==typeof e?e(t):o(o({},t),e)),n},m=function(e){var t=d(e.components);return i.a.createElement(l.Provider,{value:t},e.children)},p={inlineCode:"code",wrapper:function(e){var t=e.children;return i.a.createElement(i.a.Fragment,{},t)}},u=i.a.forwardRef((function(e,t){var n=e.components,r=e.mdxType,a=e.originalType,c=e.parentName,l=s(e,["components","mdxType","originalType","parentName"]),m=d(n),u=r,v=m["".concat(c,".").concat(u)]||m[u]||p[u]||a;return n?i.a.createElement(v,o(o({ref:t},l),{},{components:n})):i.a.createElement(v,o({ref:t},l))}));function v(e,t){var n=arguments,r=t&&t.mdxType;if("string"==typeof e||r){var a=n.length,c=new Array(a);c[0]=u;var o={};for(var s in t)hasOwnProperty.call(t,s)&&(o[s]=t[s]);o.originalType=e,o.mdxType="string"==typeof e?e:r,c[1]=o;for(var l=2;l<a;l++)c[l]=n[l];return i.a.createElement.apply(null,c)}return i.a.createElement.apply(null,n)}u.displayName="MDXCreateElement"}}]);