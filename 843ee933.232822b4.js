(window.webpackJsonp=window.webpackJsonp||[]).push([[29],{123:function(e,t,n){"use strict";n.d(t,"a",(function(){return d})),n.d(t,"b",(function(){return u}));var a=n(0),i=n.n(a);function r(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function o(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function s(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?o(Object(n),!0).forEach((function(t){r(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):o(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function c(e,t){if(null==e)return{};var n,a,i=function(e,t){if(null==e)return{};var n,a,i={},r=Object.keys(e);for(a=0;a<r.length;a++)n=r[a],t.indexOf(n)>=0||(i[n]=e[n]);return i}(e,t);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);for(a=0;a<r.length;a++)n=r[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(i[n]=e[n])}return i}var l=i.a.createContext({}),m=function(e){var t=i.a.useContext(l),n=t;return e&&(n="function"==typeof e?e(t):s(s({},t),e)),n},d=function(e){var t=m(e.components);return i.a.createElement(l.Provider,{value:t},e.children)},p={inlineCode:"code",wrapper:function(e){var t=e.children;return i.a.createElement(i.a.Fragment,{},t)}},b=i.a.forwardRef((function(e,t){var n=e.components,a=e.mdxType,r=e.originalType,o=e.parentName,l=c(e,["components","mdxType","originalType","parentName"]),d=m(n),b=a,u=d["".concat(o,".").concat(b)]||d[b]||p[b]||r;return n?i.a.createElement(u,s(s({ref:t},l),{},{components:n})):i.a.createElement(u,s({ref:t},l))}));function u(e,t){var n=arguments,a=t&&t.mdxType;if("string"==typeof e||a){var r=n.length,o=new Array(r);o[0]=b;var s={};for(var c in t)hasOwnProperty.call(t,c)&&(s[c]=t[c]);s.originalType=e,s.mdxType="string"==typeof e?e:a,o[1]=s;for(var l=2;l<r;l++)o[l]=n[l];return i.a.createElement.apply(null,o)}return i.a.createElement.apply(null,n)}b.displayName="MDXCreateElement"},97:function(e,t,n){"use strict";n.r(t),n.d(t,"frontMatter",(function(){return o})),n.d(t,"metadata",(function(){return s})),n.d(t,"toc",(function(){return c})),n.d(t,"default",(function(){return m}));var a=n(3),i=n(7),r=(n(0),n(123)),o={slug:"zio-jms-keep-alive",title:"Keep alive for JMS connections",tags:["ZIO","Streams","JMS"],author:"Andreas Gies",author_url:"https://github.com/atooni"},s={permalink:"/blended-zio/blog/zio-jms-keep-alive",source:"@site/blog/2020-11-05-JmsKeepAlive.md",description:"This article concludes the mini series exploring the ZIO Stream API and shows how a simple keep-alive mechanism can be added to a JMS based stream. This will check the health of the underlying JMS connection and issue a connection restart if required.",date:"2020-11-05T00:00:00.000Z",tags:[{label:"ZIO",permalink:"/blended-zio/blog/tags/zio"},{label:"Streams",permalink:"/blended-zio/blog/tags/streams"},{label:"JMS",permalink:"/blended-zio/blog/tags/jms"}],title:"Keep alive for JMS connections",truncated:!0,prevItem:{title:"Integration Testing",permalink:"/blended-zio/blog/integration-testing"},nextItem:{title:"Recovery for (JMS) Streams",permalink:"/blended-zio/blog/zio-streams-autorecover"}},c=[{value:"References to related posts",id:"references-to-related-posts",children:[]},{value:"A simple Keep Alive monitor",id:"a-simple-keep-alive-monitor",children:[]},{value:"Using the Keep alive monitor with JMS connections",id:"using-the-keep-alive-monitor-with-jms-connections",children:[{value:"Defining a JMS Keep alive",id:"defining-a-jms-keep-alive",children:[]},{value:"Defining a Keep alive Stream",id:"defining-a-keep-alive-stream",children:[]},{value:"Create the JMS Keep Alive Monitor",id:"create-the-jms-keep-alive-monitor",children:[]}]},{value:"Instrumenting a JMS connection with a keep alive monitor",id:"instrumenting-a-jms-connection-with-a-keep-alive-monitor",children:[]},{value:"The program to be run",id:"the-program-to-be-run",children:[]},{value:"Conclusion",id:"conclusion",children:[]},{value:"Next steps",id:"next-steps",children:[]}],l={toc:c};function m(e){var t=e.components,n=Object(i.a)(e,["components"]);return Object(r.b)("wrapper",Object(a.a)({},l,n,{components:t,mdxType:"MDXLayout"}),Object(r.b)("p",null,"This article concludes the mini series exploring the ZIO Stream API and shows how a simple keep-alive mechanism can be added to a JMS based stream. This will check the health of the underlying JMS connection and issue a connection restart if required. "),Object(r.b)("h1",{id:"why-do-we-need-a-keep-alive"},"Why do we need a keep alive"),Object(r.b)("p",null,"In our existing application we have noticed that in some circumstances a connection that still exists and is reported as ",Object(r.b)("inlineCode",{parentName:"p"},"connected")," within the monitoring tools does not work as expected. In the case of JMS this usually happens when a particular connection is only used to receive messages. The connection may appear as ",Object(r.b)("inlineCode",{parentName:"p"},"connected")," and also have associated JMS sessions and consumers, but still will not receive any messages from the JMS broker."),Object(r.b)("p",null,"Many JMS providers have implemented a keep alive mechanism, but in practice those have been proven to be somewhat difficult:"),Object(r.b)("ul",null,Object(r.b)("li",{parentName:"ul"},"They do not work in some edge cases such as restarting network switches on WAN connections."),Object(r.b)("li",{parentName:"ul"},"They are not part of the JMS specification and therefore will be different from vendor to vendor and are definitely not mandatory."),Object(r.b)("li",{parentName:"ul"},"They usually require some vendor specific code to be configured (if not configured via properties over JNDI).")),Object(r.b)("p",null,"A connection which is also used to produce messages normally does require a keep alive monitor because it would encounter a ",Object(r.b)("inlineCode",{parentName:"p"},"JMSException")," when sends are attempted over a stale connection and therefore the connection could be recovered during normal error handling."),Object(r.b)("p",null,"In this article I will pick up from the ",Object(r.b)("a",Object(a.a)({parentName:"p"},{href:"/blended-zio/blog/zio-streams-autorecover"}),"last article"),", where I investigated how we could leverage the ZIO Api to automatically recover from an exception in the JMS layer without terminating the ZIO stream with an exception."),Object(r.b)("p",null,"We will show a simple keep alive monitor, which doesn't know anything about JMS or streams at all. Then we will create an instance of that monitor watching a created JMS connection issuing a reconnect once the maximum number of missed keep alive events is reached."),Object(r.b)("div",{className:"admonition admonition-info alert alert--info"},Object(r.b)("div",Object(a.a)({parentName:"div"},{className:"admonition-heading"}),Object(r.b)("h5",{parentName:"div"},Object(r.b)("span",Object(a.a)({parentName:"h5"},{className:"admonition-icon"}),Object(r.b)("svg",Object(a.a)({parentName:"span"},{xmlns:"http://www.w3.org/2000/svg",width:"14",height:"16",viewBox:"0 0 14 16"}),Object(r.b)("path",Object(a.a)({parentName:"svg"},{fillRule:"evenodd",d:"M7 2.3c3.14 0 5.7 2.56 5.7 5.7s-2.56 5.7-5.7 5.7A5.71 5.71 0 0 1 1.3 8c0-3.14 2.56-5.7 5.7-5.7zM7 1C3.14 1 0 4.14 0 8s3.14 7 7 7 7-3.14 7-7-3.14-7-7-7zm1 3H6v5h2V4zm0 6H6v2h2v-2z"})))),"info")),Object(r.b)("div",Object(a.a)({parentName:"div"},{className:"admonition-content"}),Object(r.b)("p",{parentName:"div"},"The complete source code used in this article can be found on ",Object(r.b)("a",Object(a.a)({parentName:"p"},{href:"https://github.com/blended-zio/blended-zio/tree/main/blended.zio.streams"}),"github")))),Object(r.b)("h2",{id:"references-to-related-posts"},"References to related posts"),Object(r.b)("ul",null,Object(r.b)("li",{parentName:"ul"},Object(r.b)("a",Object(a.a)({parentName:"li"},{href:"/blended-zio/blog/zio-streams-jms"}),"Basic streams with JMS")),Object(r.b)("li",{parentName:"ul"},Object(r.b)("a",Object(a.a)({parentName:"li"},{href:"/blended-zio/blog/zio-streams-autorecover"}),"Auto Recovery for ZIO streams"))),Object(r.b)("h2",{id:"a-simple-keep-alive-monitor"},"A simple Keep Alive monitor"),Object(r.b)("p",null,"A keep alive monitor is more or less a counter that is increased at certain intervals. It can be reset by sending it ",Object(r.b)("inlineCode",{parentName:"p"},"alive")," signals. Whenever\nthe counter reaches a defined value ",Object(r.b)("inlineCode",{parentName:"p"},"n")," that practically means that for the duration of ",Object(r.b)("inlineCode",{parentName:"p"},"n * interval")," the monitor hasn't received a signal. The monitor as such does\nnot need to know about the entity it monitors, in our case the JMS connection."),Object(r.b)("pre",null,Object(r.b)("code",Object(a.a)({parentName:"pre"},{className:"language-scala"}),"trait KeepAliveMonitor {\n\n  /**\n   * An id to identify the monitor in the logs and metrics.\n   */\n  val id: String\n\n  /**\n   * The maximum number of allowed missed keep alive signals.\n   */\n  val allowed: Int\n\n  /**\n   * Signal that the monitored entity is still alive. This will cause to reset the missed\n   * counter to 0.\n   */\n  def alive: ZIO[Logging, Nothing, Unit]\n\n  /**\n   * Start the monitor with a given interval. At every interval tick the counter\n   * for missed keep alives will be incremented. If the counter reaches the maximum allowed\n   * missed keep alives, run will terminate and yield the current counter (which happens to\n   * be the allowed maximum).\n   */\n  def run(interval: Duration): ZIO[Clock with Logging, Nothing, Int]\n\n  /**\n   * Return the current count of missed keep alives\n   */\n  def current: ZIO[Any, Nothing, Int]\n}\n")),Object(r.b)("p",null,"The implementation for this interface is fairly straight forward. Within the ",Object(r.b)("inlineCode",{parentName:"p"},"run")," method we execute a step effect, which simply increases the internal\ncounter. If the counter has reached the given maximum, the step function terminates, otherwise the next step is scheduled after the given interval."),Object(r.b)("p",null,"Overall, ",Object(r.b)("inlineCode",{parentName:"p"},"run")," will terminate once the given max count has been reached. Therefore it is always a good idea fo users of the monitor to execute ",Object(r.b)("inlineCode",{parentName:"p"},"monitor.run")," in it's own fiber."),Object(r.b)("pre",null,Object(r.b)("code",Object(a.a)({parentName:"pre"},{className:"language-scala"}),'  private[streams] def run(interval: Duration) = {\n\n    def go: ZIO[Clock, Nothing, Unit] = ZIO.ifM(missed.updateAndGet(_ + 1).map(_ == allowedKeepAlives))(\n      ZIO.unit,\n      go.schedule(Schedule.duration(interval)).flatMap(_ => ZIO.unit)\n    )\n\n    for {\n      _ <- log.trace(s"Starting KeepAliveMonitor [$name]")\n      _ <- go.schedule(Schedule.duration(interval))\n      c <- missed.get\n      _ <- log.trace(s"KeepAliveMonitor [$name] finished with maximum keep alives of [$c]")\n    } yield (c)\n  }\n')),Object(r.b)("h2",{id:"using-the-keep-alive-monitor-with-jms-connections"},"Using the Keep alive monitor with JMS connections"),Object(r.b)("p",null,"With the JMS based streams explained ",Object(r.b)("a",Object(a.a)({parentName:"p"},{href:"/blended-zio/blog/zio-streams-jms"}),"here")," and the general keep alive monitor we can now build a monitor that determines whether a given JMS connection is healthy. We do that by using the connection to be monitored to regularly send and receive messages. Whenever a message is received, we execute ",Object(r.b)("inlineCode",{parentName:"p"},"alive")," on the underlying monitor - effectively resetting the counter."),Object(r.b)("h3",{id:"defining-a-jms-keep-alive"},"Defining a JMS Keep alive"),Object(r.b)("p",null,"From the API perspective we want to describe a ",Object(r.b)("inlineCode",{parentName:"p"},"JmsKeepAliveMonitor")," without actually executing it. That is fairly straightforward as we just need to know the JMS destination we want to use for our keep alive messages, the interval to send messages and finally the maximum number of intervals we would accept not receiving a keep alive message. "),Object(r.b)("pre",null,Object(r.b)("code",Object(a.a)({parentName:"pre"},{className:"language-scala"}),"final case class JmsKeepAliveMonitor(\n  dest: JmsDestination,\n  interval: Duration,\n  allowed: Int\n)\n")),Object(r.b)("div",{className:"admonition admonition-caution alert alert--warning"},Object(r.b)("div",Object(a.a)({parentName:"div"},{className:"admonition-heading"}),Object(r.b)("h5",{parentName:"div"},Object(r.b)("span",Object(a.a)({parentName:"h5"},{className:"admonition-icon"}),Object(r.b)("svg",Object(a.a)({parentName:"span"},{xmlns:"http://www.w3.org/2000/svg",width:"16",height:"16",viewBox:"0 0 16 16"}),Object(r.b)("path",Object(a.a)({parentName:"svg"},{fillRule:"evenodd",d:"M8.893 1.5c-.183-.31-.52-.5-.887-.5s-.703.19-.886.5L.138 13.499a.98.98 0 0 0 0 1.001c.193.31.53.501.886.501h13.964c.367 0 .704-.19.877-.5a1.03 1.03 0 0 0 .01-1.002L8.893 1.5zm.133 11.497H6.987v-2.003h2.039v2.003zm0-3.004H6.987V5.987h2.039v4.006z"})))),"caution")),Object(r.b)("div",Object(a.a)({parentName:"div"},{className:"admonition-content"}),Object(r.b)("p",{parentName:"div"},"Keep in mind that the library has prototyping character for now, so some elements like the ping message format are hard coded for the time being and need to be fleshed out later on."))),Object(r.b)("h3",{id:"defining-a-keep-alive-stream"},"Defining a Keep alive Stream"),Object(r.b)("p",null,"First of all, we will create a stream to produce Keep Alive messages "),Object(r.b)("pre",null,Object(r.b)("code",Object(a.a)({parentName:"pre"},{className:"language-scala"}),'          val startKeepAliveSender = {\n\n            val sdf = new SimpleDateFormat("yyyy-MM-dd-HH:mm:ss:SSS")\n\n            val stream = ZStream\n              .fromSchedule(Schedule.spaced(keepAlive.interval))\n              .mapM(_ =>\n                currentTime(TimeUnit.MILLISECONDS)\n                  .map(t => s"KeepAlive ($con) : ${sdf.format(t)}")\n              )\n\n            createSession(con).use(jmsSess =>\n              createProducer(jmsSess).use(prod => stream.run(jmsSink(prod, keepAlive.dest)))\n            )\n          }\n')),Object(r.b)("p",null,"Now we need to define a consumer - in other words a ZIO stream - and for each message received we want to execute ",Object(r.b)("inlineCode",{parentName:"p"},"alive")," on a given ",Object(r.b)("inlineCode",{parentName:"p"},"KeepAliveMonitor"),"."),Object(r.b)("pre",null,Object(r.b)("code",Object(a.a)({parentName:"pre"},{className:"language-scala"}),"          def startKeepAliveReceiver(kam: KeepAliveMonitor) = createSession(con).use { jmsSess =>\n            createConsumer(jmsSess, keepAlive.dest).use(cons => jmsStream(cons).foreach(_ => kam.alive))\n          }\n")),Object(r.b)("h3",{id:"create-the-jms-keep-alive-monitor"},"Create the JMS Keep Alive Monitor"),Object(r.b)("p",null,"The JMS keep alive monitor will be created once a connection configured with monitoring is established. We also need a destination that shall be used for sending and receiving the keep alive messages, an interval and the maximum allowed missed keep alives."),Object(r.b)("p",null,"With those parameters the JMS keep alive monitor is straight forward:"),Object(r.b)("ol",null,Object(r.b)("li",{parentName:"ol"},"Create an an instance of a general ",Object(r.b)("inlineCode",{parentName:"li"},"KeepAliveMonitor")),Object(r.b)("li",{parentName:"ol"},"Start the sink for keep alives"),Object(r.b)("li",{parentName:"ol"},"Start the stream to receive keep alives"),Object(r.b)("li",{parentName:"ol"},"Fork the run method of the just created monitor"),Object(r.b)("li",{parentName:"ol"},"Once run terminates, interrupt the stream and sink"),Object(r.b)("li",{parentName:"ol"},"Terminate with the current count of the underlying monitor")),Object(r.b)("pre",null,Object(r.b)("code",Object(a.a)({parentName:"pre"},{className:"language-scala"}),'          val run = for {\n            kam  <- DefaultKeepAliveMonitor.make(s"${con.id}-KeepAlive", keepAlive.allowed)\n            send <- startKeepAliveSender.fork\n            rec  <- startKeepAliveReceiver(kam).fork\n            _    <- kam.run(keepAlive.interval)\n            _    <- send.interrupt *> rec.interrupt\n            c    <- kam.current\n          } yield (c)\n\n          for {\n            _ <- log.debug(s"Adding keep Alive to $con")\n            _ <- run.flatMap(missed => reconnect(con, Some(new KeepAliveException(con.id, missed)))).forkDaemon\n          } yield ()\n')),Object(r.b)("p",null,"Putting all our effects together, we can now use the ",Object(r.b)("inlineCode",{parentName:"p"},"JmsConnectionFactory")," and and the ",Object(r.b)("inlineCode",{parentName:"p"},"JmsKeepAlive"),"in our data model to create an instrument a JMS connection:"),Object(r.b)("pre",null,Object(r.b)("code",Object(a.a)({parentName:"pre"},{className:"language-scala"}),'        for {\n          _  <- log.debug(s"Connecting to [${cf.id}] with clientId [$clientId]")\n          jc <- effectBlocking {\n                  val jmsConn: Connection = cf.factory.createConnection()\n                  jmsConn.setClientID(clientId)\n                  jmsConn.start()\n                  jmsConn\n                }.flatMapError { t =>\n                  for {\n                    _ <- scheduleRecover(cf, clientId, Some(t))\n                  } yield t\n                }.refineOrDie { case t: JMSException => t }\n          c   = JmsConnection(cf, jc, clientId)\n          _  <- ZIO.foreach(cf.keepAlive)(ka => addKeepAlive(c, ka))\n          _  <- addConnection(c)\n          _  <- log.debug(s"Created [$c]")\n        } yield c\n')),Object(r.b)("h2",{id:"instrumenting-a-jms-connection-with-a-keep-alive-monitor"},"Instrumenting a JMS connection with a keep alive monitor"),Object(r.b)("p",null,"From the API perspective we configure the keep as an ",Object(r.b)("inlineCode",{parentName:"p"},"Option[JmsKeepAliveMonitor]")," within the ",Object(r.b)("inlineCode",{parentName:"p"},"JmsConnectionFactory"),". If the field is defined, the underlying connection manager will instantiate a keep alive stream for each connection that is created from that connection factory. "),Object(r.b)("pre",null,Object(r.b)("code",Object(a.a)({parentName:"pre"},{className:"language-scala"}),'  private def amqCF = JmsConnectionFactory(\n    "amq:amq",\n    new ActiveMQConnectionFactory("vm://simple?create=false"),\n    3.seconds,\n    Some(JmsKeepAliveMonitor(JmsQueue("keepAlive"), 1.second, 3))\n  )\n')),Object(r.b)("h2",{id:"the-program-to-be-run"},"The program to be run"),Object(r.b)("p",null,"In the program we have to use the recovering streams we have seen in the last ",Object(r.b)("a",Object(a.a)({parentName:"p"},{href:"/blended-zio/blog/zio-streams-autorecover"}),"article"),", so that an automated recovery can happen if the keep alive counter exceeds and subsequently the connection is closed and restarted. "),Object(r.b)("pre",null,Object(r.b)("code",Object(a.a)({parentName:"pre"},{className:"language-scala"}),'  private val program = for {\n    _         <- putStrLn("Starting JMS Broker") *> ZIO.service[BrokerService]\n    f         <- ZIO.unit.schedule(Schedule.duration(1.minutes)).fork\n    jmsStream <- recoveringJmsStream(amqCF, clientId, testDest, 2.seconds)\n    jmsSink   <- recoveringJmsSink(amqCF, clientId, testDest, 1.second)\n    consumer  <- jmsStream.foreach(s => putStrLn(s)).fork\n    producer  <- stream.run(jmsSink).fork\n    _         <- f.join >>> consumer.interrupt >>> producer.interrupt\n  } yield ()\n')),Object(r.b)("h2",{id:"conclusion"},"Conclusion"),Object(r.b)("p",null,"We have added a simple keep alive mechanism to the JMS connections we have discussed in the previous articles. The keep alive mechanism builds on the streams with auto recovery and triggers a reconnect once a limit of maximum missed keep alives has been reached. The reconnect then triggers the recovery and reconnect as defined for auto recovery."),Object(r.b)("p",null,"For the users of the stream the keep alive and potential reconnect is completely transparent. "),Object(r.b)("h2",{id:"next-steps"},"Next steps"),Object(r.b)("p",null,"Apart from finalizing the API there are more areas to explore:"),Object(r.b)("ul",null,Object(r.b)("li",{parentName:"ul"},"Use defined types rather than only String as message payloads."),Object(r.b)("li",{parentName:"ul"},"Support arbitrary message properties."),Object(r.b)("li",{parentName:"ul"},"Look into defining message flows on top of streams with error handling and acknowledgements."),Object(r.b)("li",{parentName:"ul"},"Explore ",Object(r.b)("a",Object(a.a)({parentName:"li"},{href:"https://github.com/zio/zio-zmx"}),"zio-zmx")," to visualize the current state of all fibers within a running application (for learning about threads primarily)"),Object(r.b)("li",{parentName:"ul"},"Build a sample application that represents a JMS bridge",Object(r.b)("ul",{parentName:"li"},Object(r.b)("li",{parentName:"ul"},"Consume message from provider A"),Object(r.b)("li",{parentName:"ul"},"Send the message to provider B"),Object(r.b)("li",{parentName:"ul"},"Acknowledge the message if and only if the send was successful, otherwise pass the message to a retry handler"),Object(r.b)("li",{parentName:"ul"},"Replay messages from the retry handler up to a given retry count until the send was successful. If the maximum retries have been reached or a given amount of time has passed before the send was successful, the message shall be processed by an error handler."),Object(r.b)("li",{parentName:"ul"},"Messages in the retry handler shall be persisted and survive an application restart.")))))}m.isMDXComponent=!0}}]);