(window.webpackJsonp=window.webpackJsonp||[]).push([[8],{113:function(e,t,n){"use strict";n.d(t,"a",(function(){return b})),n.d(t,"b",(function(){return u}));var r=n(0),a=n.n(r);function i(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function o(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);t&&(r=r.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,r)}return n}function c(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?o(Object(n),!0).forEach((function(t){i(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):o(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function l(e,t){if(null==e)return{};var n,r,a=function(e,t){if(null==e)return{};var n,r,a={},i=Object.keys(e);for(r=0;r<i.length;r++)n=i[r],t.indexOf(n)>=0||(a[n]=e[n]);return a}(e,t);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(r=0;r<i.length;r++)n=i[r],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(a[n]=e[n])}return a}var s=a.a.createContext({}),p=function(e){var t=a.a.useContext(s),n=t;return e&&(n="function"==typeof e?e(t):c(c({},t),e)),n},b=function(e){var t=p(e.components);return a.a.createElement(s.Provider,{value:t},e.children)},d={inlineCode:"code",wrapper:function(e){var t=e.children;return a.a.createElement(a.a.Fragment,{},t)}},g=a.a.forwardRef((function(e,t){var n=e.components,r=e.mdxType,i=e.originalType,o=e.parentName,s=l(e,["components","mdxType","originalType","parentName"]),b=p(n),g=r,u=b["".concat(o,".").concat(g)]||b[g]||d[g]||i;return n?a.a.createElement(u,c(c({ref:t},s),{},{components:n})):a.a.createElement(u,c({ref:t},s))}));function u(e,t){var n=arguments,r=t&&t.mdxType;if("string"==typeof e||r){var i=n.length,o=new Array(i);o[0]=g;var c={};for(var l in t)hasOwnProperty.call(t,l)&&(c[l]=t[l]);c.originalType=e,c.mdxType="string"==typeof e?e:r,o[1]=c;for(var s=2;s<i;s++)o[s]=n[s];return a.a.createElement.apply(null,o)}return a.a.createElement.apply(null,n)}g.displayName="MDXCreateElement"},75:function(e,t,n){"use strict";n.r(t),n.d(t,"frontMatter",(function(){return o})),n.d(t,"metadata",(function(){return c})),n.d(t,"toc",(function(){return l})),n.d(t,"default",(function(){return p}));var r=n(3),a=n(7),i=(n(0),n(113)),o={id:"index",title:"Blended ZIO Core"},c={unversionedId:"core/index",id:"core/index",isDocsHomePage:!1,title:"Blended ZIO Core",description:"Functionality that is required by all blended containers.",source:"@site/docs/core/index.md",slug:"/core/index",permalink:"/blended-zio/docs/core/index",version:"current",sidebar:"someSidebar",previous:{title:"Service based containers",permalink:"/blended-zio/docs/container"},next:{title:"Blended ZIO JMX",permalink:"/blended-zio/docs/jmx/index"}},l=[{value:"Configuring Blended Containers",id:"configuring-blended-containers",children:[]},{value:"Evaluate simple string expressions",id:"evaluate-simple-string-expressions",children:[]},{value:"Simple crypto service",id:"simple-crypto-service",children:[]},{value:"Using the services",id:"using-the-services",children:[]}],s={toc:l};function p(e){var t=e.components,n=Object(a.a)(e,["components"]);return Object(i.b)("wrapper",Object(r.a)({},s,n,{components:t,mdxType:"MDXLayout"}),Object(i.b)("p",null,"Functionality that is required by all ",Object(i.b)("em",{parentName:"p"},"blended")," containers."),Object(i.b)("h2",{id:"configuring-blended-containers"},"Configuring Blended Containers"),Object(i.b)("p",null,"As outlined ","[here]",'({{< relref "/docs/blended_container.md" >}}) all modules that require configuration should be able to use external configuration files containing place holders to specify lookups from environment variables or resolve encrypted values.'),Object(i.b)("p",null,"For example, the configuration for an LDAP service might be:"),Object(i.b)("pre",null,Object(i.b)("code",Object(r.a)({parentName:"pre"},{}),'{\n  url             : "ldaps://ldap.$[[env]].$[[country]]:4712"\n  systemUser"     : "admin"\n  systemPassword" : "$[(encrypted)[5c4e48e1920836f68f1abbaf60e9b026]]"\n  userBase"       : "o=employee"\n  userAttribute"  : "uid"\n  groupBase"      : "ou=sib,ou=apps,o=global"\n  groupAttribute" : "cn"\n  groupSearch"    : "(member={0})"\n}\n')),Object(i.b)("p",null,"The ZIO ecosystem has a library called ",Object(i.b)("a",Object(r.a)({parentName:"p"},{href:"https://zio.github.io/zio-config/"}),"zio-config")," which supports different sources such as property files, HOCON, YAML or even the command line. At the core of the library are ConfigDescriptors which can be used to read the config information into config case classes. The descriptors are also used to generate documentation for the available config options or reports over the configuration values used within the application."),Object(i.b)("p",null,"Following the ",Object(i.b)("a",Object(r.a)({parentName:"p"},{href:"https://discord.com/channels/629491597070827530/633028431000502273/767663251092930591"}),"advice")," from the zio-config library author on discord, we introduce a ",Object(i.b)("inlineCode",{parentName:"p"},"LazyConfigString")," as follows:"),Object(i.b)("pre",null,Object(i.b)("code",Object(r.a)({parentName:"pre"},{className:"language-scala",metastring:'title="Descriptor"',title:'"Descriptor"'}),"sealed abstract case class LazyConfigString(value: String)\n\nobject LazyConfigString {\n\n  final case class Raw(raw: String) {\n    def evaluate(\n      ctxt: Map[String, String]\n    ): ZIO[StringEvaluator.StringEvaluator, EvaluatorException, LazyConfigString] = for {\n      se  <- ZIO.service[StringEvaluator.Service]\n      res <- se.resolveString(raw, ctxt)\n    } yield (new LazyConfigString(res) {})\n  }\n\n  val configString: ConfigDescriptor[Raw]               =\n    string(Raw.apply, Raw.unapply)\n  def configString(path: String): ConfigDescriptor[Raw] = nested(path)(configString)\n\n}\n")),Object(i.b)("p",null,"Essentially we define a class ",Object(i.b)("inlineCode",{parentName:"p"},"LazyConfigString"),", which instances will eventually hold the resolved config value. Making the class ",Object(i.b)("inlineCode",{parentName:"p"},"sealed")," and ",Object(i.b)("inlineCode",{parentName:"p"},"abstract")," ensures that new instances can only bo created from within the companion object."),Object(i.b)("p",null,"Within the companion object the case class ",Object(i.b)("inlineCode",{parentName:"p"},"Raw")," can be instantiated with Strings read from the config sources. Also, within this class the ",Object(i.b)("inlineCode",{parentName:"p"},"evaluate")," method holds the effect describing the resolution of the raw config string to a real value. Essentially we are deferring the resolution to a ",Object(i.b)("inlineCode",{parentName:"p"},"StringEvaluator")," service."),Object(i.b)("p",null,"At last we need to provide a config descriptor for ",Object(i.b)("inlineCode",{parentName:"p"},"LazyConfigStrings"),", so that the generated documentation will reflect that the config values are subject to lazy evaluation."),Object(i.b)("p",null,"Using the ",Object(i.b)("inlineCode",{parentName:"p"},"LazyConfigString"),", we can define the ",Object(i.b)("inlineCode",{parentName:"p"},"LDAPConfig")," as follows:"),Object(i.b)("pre",null,Object(i.b)("code",Object(r.a)({parentName:"pre"},{className:"language-scala",metastring:'title="Sample Config Descriptor"',title:'"Sample',Config:!0,'Descriptor"':!0}),'object LDAPConfig {\n\n  import LazyConfigString._\n\n  def desc: ConfigDescriptor[LDAPConfig] = (\n    configString("url") ?? "The url to connect to the LDAP server" |@|\n      configString("systemUser") |@|\n      configString("systemPassword") |@|\n      configString("userBase") |@|\n      configString("userAttribute") |@|\n      configString("groupBase") |@|\n      configString("groupAttribute") |@|\n      configString("groupSearch")\n  )(LDAPConfig.apply, LDAPConfig.unapply)\n}\n\ncase class LDAPConfig(\n  url: LazyConfigString.Raw,\n  systemUser: LazyConfigString.Raw,\n  systemPassword: LazyConfigString.Raw,\n  userBase: LazyConfigString.Raw,\n  userAttribute: LazyConfigString.Raw,\n  groupBase: LazyConfigString.Raw,\n  groupAttribute: LazyConfigString.Raw,\n  groupSearch: LazyConfigString.Raw\n)\n')),Object(i.b)("p",null,"To access a config value, a layer with a ",Object(i.b)("inlineCode",{parentName:"p"},"StringEvaluator")," must be referenced:"),Object(i.b)("pre",null,Object(i.b)("code",Object(r.a)({parentName:"pre"},{className:"language-scala",metastring:'title="Access Config"',title:'"Access','Config"':!0}),'  private val desc: ConfigDescriptor[LDAPConfig] = LDAPConfig.desc\n  private val ctxt: Map[String, String]          = Map("user" -> "ADMIN", "env" -> "dev", "country" -> "es")\n\n  private def simpleEval(src: ConfigSource) = testM("Evaluate a simple config map")(\n    (for {\n      cfg <- ZIO.fromEither(read(desc.from(src)))\n      pwd <- cfg.systemPassword.evaluate(ctxt)\n    } yield assert(pwd.value)(equalTo("blended"))).provideLayer(evalLayer)\n  )\n')),Object(i.b)("p",null,"With the code above, zio-config will generate the following report in markdown format:"),Object(i.b)("div",{className:"admonition admonition-note alert alert--secondary"},Object(i.b)("div",Object(r.a)({parentName:"div"},{className:"admonition-heading"}),Object(i.b)("h5",{parentName:"div"},Object(i.b)("span",Object(r.a)({parentName:"h5"},{className:"admonition-icon"}),Object(i.b)("svg",Object(r.a)({parentName:"span"},{xmlns:"http://www.w3.org/2000/svg",width:"14",height:"16",viewBox:"0 0 14 16"}),Object(i.b)("path",Object(r.a)({parentName:"svg"},{fillRule:"evenodd",d:"M6.3 5.69a.942.942 0 0 1-.28-.7c0-.28.09-.52.28-.7.19-.18.42-.28.7-.28.28 0 .52.09.7.28.18.19.28.42.28.7 0 .28-.09.52-.28.7a1 1 0 0 1-.7.3c-.28 0-.52-.11-.7-.3zM8 7.99c-.02-.25-.11-.48-.31-.69-.2-.19-.42-.3-.69-.31H6c-.27.02-.48.13-.69.31-.2.2-.3.44-.31.69h1v3c.02.27.11.5.31.69.2.2.42.31.69.31h1c.27 0 .48-.11.69-.31.2-.19.3-.42.31-.69H8V7.98v.01zM7 2.3c-3.14 0-5.7 2.54-5.7 5.68 0 3.14 2.56 5.7 5.7 5.7s5.7-2.55 5.7-5.7c0-3.15-2.56-5.69-5.7-5.69v.01zM7 .98c3.86 0 7 3.14 7 7s-3.14 7-7 7-7-3.12-7-7 3.14-7 7-7z"})))),"note")),Object(i.b)("div",Object(r.a)({parentName:"div"},{className:"admonition-content"}),Object(i.b)("h3",Object(r.a)({parentName:"div"},{id:"field-descriptions"}),"Field Descriptions"),Object(i.b)("table",{parentName:"div"},Object(i.b)("thead",{parentName:"table"},Object(i.b)("tr",{parentName:"thead"},Object(i.b)("th",Object(r.a)({parentName:"tr"},{align:null}),"FieldName"),Object(i.b)("th",Object(r.a)({parentName:"tr"},{align:null}),"Format"),Object(i.b)("th",Object(r.a)({parentName:"tr"},{align:null}),"Description"),Object(i.b)("th",Object(r.a)({parentName:"tr"},{align:null}),"Sources"))),Object(i.b)("tbody",{parentName:"table"},Object(i.b)("tr",{parentName:"tbody"},Object(i.b)("td",Object(r.a)({parentName:"tr"},{align:null}),"url"),Object(i.b)("td",Object(r.a)({parentName:"tr"},{align:null}),"primitive"),Object(i.b)("td",Object(r.a)({parentName:"tr"},{align:null}),"lazyly evaluated config string, The url to connect to the LDAP server"),Object(i.b)("td",Object(r.a)({parentName:"tr"},{align:null}))),Object(i.b)("tr",{parentName:"tbody"},Object(i.b)("td",Object(r.a)({parentName:"tr"},{align:null}),"systemUser"),Object(i.b)("td",Object(r.a)({parentName:"tr"},{align:null}),"primitive"),Object(i.b)("td",Object(r.a)({parentName:"tr"},{align:null}),"lazyly evaluated config string"),Object(i.b)("td",Object(r.a)({parentName:"tr"},{align:null}))),Object(i.b)("tr",{parentName:"tbody"},Object(i.b)("td",Object(r.a)({parentName:"tr"},{align:null}),"systemPassword"),Object(i.b)("td",Object(r.a)({parentName:"tr"},{align:null}),"primitive"),Object(i.b)("td",Object(r.a)({parentName:"tr"},{align:null}),"lazyly evaluated config string"),Object(i.b)("td",Object(r.a)({parentName:"tr"},{align:null}))),Object(i.b)("tr",{parentName:"tbody"},Object(i.b)("td",Object(r.a)({parentName:"tr"},{align:null}),"userBase"),Object(i.b)("td",Object(r.a)({parentName:"tr"},{align:null}),"primitive"),Object(i.b)("td",Object(r.a)({parentName:"tr"},{align:null}),"lazyly evaluated config string"),Object(i.b)("td",Object(r.a)({parentName:"tr"},{align:null}))),Object(i.b)("tr",{parentName:"tbody"},Object(i.b)("td",Object(r.a)({parentName:"tr"},{align:null}),"userAttribute"),Object(i.b)("td",Object(r.a)({parentName:"tr"},{align:null}),"primitive"),Object(i.b)("td",Object(r.a)({parentName:"tr"},{align:null}),"lazyly evaluated config string"),Object(i.b)("td",Object(r.a)({parentName:"tr"},{align:null}))),Object(i.b)("tr",{parentName:"tbody"},Object(i.b)("td",Object(r.a)({parentName:"tr"},{align:null}),"groupBase"),Object(i.b)("td",Object(r.a)({parentName:"tr"},{align:null}),"primitive"),Object(i.b)("td",Object(r.a)({parentName:"tr"},{align:null}),"lazyly evaluated config string"),Object(i.b)("td",Object(r.a)({parentName:"tr"},{align:null}))),Object(i.b)("tr",{parentName:"tbody"},Object(i.b)("td",Object(r.a)({parentName:"tr"},{align:null}),"groupAttribute"),Object(i.b)("td",Object(r.a)({parentName:"tr"},{align:null}),"primitive"),Object(i.b)("td",Object(r.a)({parentName:"tr"},{align:null}),"lazyly evaluated config string"),Object(i.b)("td",Object(r.a)({parentName:"tr"},{align:null}))),Object(i.b)("tr",{parentName:"tbody"},Object(i.b)("td",Object(r.a)({parentName:"tr"},{align:null}),"groupSearch"),Object(i.b)("td",Object(r.a)({parentName:"tr"},{align:null}),"primitive"),Object(i.b)("td",Object(r.a)({parentName:"tr"},{align:null}),"lazyly evaluated config string"),Object(i.b)("td",Object(r.a)({parentName:"tr"},{align:null}))))))),Object(i.b)("h2",{id:"evaluate-simple-string-expressions"},"Evaluate simple string expressions"),Object(i.b)("p",null,"Lazy evaluated string expressions are simple expressions as defined here:"),Object(i.b)("pre",null,Object(i.b)("code",Object(r.a)({parentName:"pre"},{className:"language-scala"}),"sealed trait StringExpression\ncase class SimpleExpression(value: String)                                      extends StringExpression\ncase class SequencedExpression(parts: Seq[StringExpression])                    extends StringExpression\ncase class ModifierExpression(modStrings: Seq[String], inner: StringExpression) extends StringExpression\n")),Object(i.b)("p",null,"The notable piece here is the ",Object(i.b)("inlineCode",{parentName:"p"},"ModifierExpression"),", which has the form"),Object(i.b)("pre",null,Object(i.b)("code",Object(r.a)({parentName:"pre"},{}),"$[modifier*[StringExpression]]\n")),Object(i.b)("p",null,"A modifier expression contains an inner expression and evaluation will be from the innermost expression outwards. After resolving the inner expression, zero or more modifiers will be applied to the resolved value for a given context. The context is a simple ",Object(i.b)("inlineCode",{parentName:"p"},"Map[String, String]")," and the normal resolution simply maps the resolved expression to the corresponding value in the map."),Object(i.b)("p",null,"For example, the expression ",Object(i.b)("inlineCode",{parentName:"p"},"$[[foo]]")," with the context map ",Object(i.b)("inlineCode",{parentName:"p"},'Map("foo" -> "bar")')," will yield ",Object(i.b)("inlineCode",{parentName:"p"},'"bar"'),"."),Object(i.b)("p",null,"Modifiers will be applied to the value resolved from the context map, for example with the context map from above"),Object(i.b)("pre",null,Object(i.b)("code",Object(r.a)({parentName:"pre"},{}),'$[(upper)[foo]] => "BAR"\n$[(left:2)[foo]] => "ba"\n')),Object(i.b)("p",null,"Modifiers are specified as:"),Object(i.b)("pre",null,Object(i.b)("code",Object(r.a)({parentName:"pre"},{className:"language-scala",metastring:'title="Modifier"',title:'"Modifier"'}),'trait Modifier {\n  def name: String\n  def op(s: String, p: String): ZIO[Any, Throwable, String]\n\n  def lookup: Boolean = true\n\n  final def modifier(\n    s: String,\n    p: String\n  ): ZIO[Any, ModifierException, String] = (for {\n    input <- ZIO.fromOption(Option(s))\n    param  = Option(p).getOrElse("")\n    mod   <- op(input, param)\n  } yield mod).mapError {\n    case me: ModifierException => me\n    case t: Throwable          => new ModifierException(this, s, p, t.getMessage)\n    case _                     => new ModifierException(this, "", p, "Segment can\'t be null")\n  }\n}\n')),Object(i.b)("div",{className:"admonition admonition-note alert alert--secondary"},Object(i.b)("div",Object(r.a)({parentName:"div"},{className:"admonition-heading"}),Object(i.b)("h5",{parentName:"div"},Object(i.b)("span",Object(r.a)({parentName:"h5"},{className:"admonition-icon"}),Object(i.b)("svg",Object(r.a)({parentName:"span"},{xmlns:"http://www.w3.org/2000/svg",width:"14",height:"16",viewBox:"0 0 14 16"}),Object(i.b)("path",Object(r.a)({parentName:"svg"},{fillRule:"evenodd",d:"M6.3 5.69a.942.942 0 0 1-.28-.7c0-.28.09-.52.28-.7.19-.18.42-.28.7-.28.28 0 .52.09.7.28.18.19.28.42.28.7 0 .28-.09.52-.28.7a1 1 0 0 1-.7.3c-.28 0-.52-.11-.7-.3zM8 7.99c-.02-.25-.11-.48-.31-.69-.2-.19-.42-.3-.69-.31H6c-.27.02-.48.13-.69.31-.2.2-.3.44-.31.69h1v3c.02.27.11.5.31.69.2.2.42.31.69.31h1c.27 0 .48-.11.69-.31.2-.19.3-.42.31-.69H8V7.98v.01zM7 2.3c-3.14 0-5.7 2.54-5.7 5.68 0 3.14 2.56 5.7 5.7 5.7s5.7-2.55 5.7-5.7c0-3.15-2.56-5.69-5.7-5.69v.01zM7 .98c3.86 0 7 3.14 7 7s-3.14 7-7 7-7-3.12-7-7 3.14-7 7-7z"})))),"note")),Object(i.b)("div",Object(r.a)({parentName:"div"},{className:"admonition-content"}),Object(i.b)("p",{parentName:"div"},"A modifier implementation can override ",Object(i.b)("inlineCode",{parentName:"p"},"lookup")," to avoid that the value resolved from the inner expression will be used to look up the final value from the context map."),Object(i.b)("p",{parentName:"div"},"The ",Object(i.b)("inlineCode",{parentName:"p"},"EncryptModifier")," does that, so that the decryption will be applied to the string resolved from the inner expression."))),Object(i.b)("h2",{id:"simple-crypto-service"},"Simple crypto service"),Object(i.b)("p",null,"The ",Object(i.b)("inlineCode",{parentName:"p"},"EncryptModifier")," is defined as"),Object(i.b)("pre",null,Object(i.b)("code",Object(r.a)({parentName:"pre"},{className:"language-scala",metastring:'title="Decryption Modifier"',title:'"Decryption','Modifier"':!0}),'object EncryptedModifier {\n\n  def create: ZIO[CryptoSupport.CryptoSupport, Nothing, Modifier] = for {\n    cs <- ZIO.service[CryptoSupport.Service]\n    mod = new Modifier {\n            override def name: String = "encrypted"\n\n            override def lookup = false\n\n            override def op(s: String, p: String): ZIO[Any, Throwable, String] = (for {\n              res <- cs.decrypt(s)\n            } yield (res))\n          }\n  } yield mod\n}\n')),Object(i.b)("p",null,"It relies on a crypto service available within the ZIO environment and simply delegates the resolution to the ",Object(i.b)("inlineCode",{parentName:"p"},"decrypt")," method of that service."),Object(i.b)("p",null,"The crypto service is defined as"),Object(i.b)("pre",null,Object(i.b)("code",Object(r.a)({parentName:"pre"},{className:"language-scala",metastring:'title="Simple Crypto Service"',title:'"Simple',Crypto:!0,'Service"':!0}),"  trait Service {\n    def encrypt(plain: String): ZIO[Any, CryptoException, String]\n    def decrypt(encrypted: String): ZIO[Any, CryptoException, String]\n  }\n")),Object(i.b)("p",null,"The default implementation can be instantiated with a password, for convenience the code also contains a default password. The password can also be provided via a file. Essentially, the provided password is used to generate a key that is then used to create an instance of a CryptoService which simply wraps some Crypto methods from Java:"),Object(i.b)("pre",null,Object(i.b)("code",Object(r.a)({parentName:"pre"},{className:"language-scala",metastring:'title="Simple Crypto Service Implementation"',title:'"Simple',Crypto:!0,Service:!0,'Implementation"':!0}),'final private class DefaultCryptoSupport(key: Key, alg: String) {\n\n  def decrypt(encrypted: String): ZIO[Any, CryptoException, String] = for {\n    bytes     <- string2Byte(encrypted)\n    ciph      <- cipher(Cipher.DECRYPT_MODE)\n    decrypted <- ZIO.effect(ciph.doFinal(bytes.toArray)).refineOrDie { case t => new CryptoFrameworkException(t) }\n  } yield (new String(decrypted))\n\n  def encrypt(plain: String): ZIO[Any, CryptoException, String] = for {\n    ciph  <- cipher(Cipher.ENCRYPT_MODE)\n    bytes <- ZIO.effect(ciph.doFinal(plain.getBytes())).refineOrDie { case t => new CryptoFrameworkException(t) }\n    res   <- byte2String(bytes.toSeq)\n  } yield res\n\n  private def cipher(mode: Int): ZIO[Any, CryptoException, Cipher] =\n    ZIO.effect { val res = Cipher.getInstance(alg); res.init(mode, key); res }.refineOrDie { case t =>\n      new CryptoFrameworkException(t)\n    }\n\n  private def byte2String(a: Seq[Byte]): ZIO[Any, Nothing, String] =\n    ZIO.collectPar(a)(b => ZIO.succeed(Integer.toHexString(b & 0xff | 0x100).substring(1))).map(_.mkString)\n\n  private def string2Byte(s: String, orig: Option[String] = None): ZIO[Any, CryptoException, Seq[Byte]] = {\n    val radix: Int = 16\n\n    (s match {\n      case ""                               => ZIO.succeed(Seq.empty)\n      case single if (single.length() == 1) =>\n        ZIO.effect(Seq(Integer.parseInt(single, radix).toByte)).refineOrDie { case _: NumberFormatException =>\n          new InvalidInputException(orig.getOrElse(s))\n        }\n      case s                                =>\n        string2Byte(s.substring(2), Some(orig.getOrElse(s)))\n          .map(rest => Seq(Integer.parseInt(s.substring(0, 2), radix).toByte) ++ rest)\n    })\n  }\n}\n')),Object(i.b)("h2",{id:"using-the-services"},"Using the services"),Object(i.b)("p",null,"To use the services resolving config string, a layer with all required services must be provided:"),Object(i.b)("pre",null,Object(i.b)("code",Object(r.a)({parentName:"pre"},{className:"language-scala",metastring:'title="Layer Provisioning"',title:'"Layer','Provisioning"':!0}),"  private val logSlf4j = Slf4jLogger.make((_, message) => message)\n\n  private val cryptoDefault: ZLayer[Any, Nothing, CryptoSupport.CryptoSupport] =\n    CryptoSupport.default.orDie\n\n  private val mods: ZIO[Any, Nothing, Seq[Modifier]] = EncryptedModifier.create.provideLayer(cryptoDefault).map { em =>\n    Seq(UpperModifier, LowerModifier, em)\n  }\n\n  private val evalLayer: ZLayer[Any, Nothing, StringEvaluator.StringEvaluator] =\n    logSlf4j >>> StringEvaluator.fromMods(mods)\n")),Object(i.b)("p",null,"This layer can be provided to an effect by the means of ",Object(i.b)("inlineCode",{parentName:"p"},"provideLayer")),Object(i.b)("pre",null,Object(i.b)("code",Object(r.a)({parentName:"pre"},{className:"language-scala",metastring:'title="Layer Access"',title:'"Layer','Access"':!0}),'  private val desc: ConfigDescriptor[LDAPConfig] = LDAPConfig.desc\n  private val ctxt: Map[String, String]          = Map("user" -> "ADMIN", "env" -> "dev", "country" -> "es")\n\n  private def simpleEval(src: ConfigSource) = testM("Evaluate a simple config map")(\n    (for {\n      cfg <- ZIO.fromEither(read(desc.from(src)))\n      pwd <- cfg.systemPassword.evaluate(ctxt)\n    } yield assert(pwd.value)(equalTo("blended"))).provideLayer(evalLayer)\n  )\n')),Object(i.b)("p",null,"Finally, the config can be resolved from a config source created from a ",Object(i.b)("inlineCode",{parentName:"p"},"Map")," with ",Object(i.b)("inlineCode",{parentName:"p"},"ConfigSource.fromMap"),":"),Object(i.b)("pre",null,Object(i.b)("code",Object(r.a)({parentName:"pre"},{className:"language-scala",metastring:'title="Sample config class"',title:'"Sample',config:!0,'class"':!0}),'object LDAPConfig {\n\n  import LazyConfigString._\n\n  def desc: ConfigDescriptor[LDAPConfig] = (\n    configString("url") ?? "The url to connect to the LDAP server" |@|\n      configString("systemUser") |@|\n      configString("systemPassword") |@|\n      configString("userBase") |@|\n      configString("userAttribute") |@|\n      configString("groupBase") |@|\n      configString("groupAttribute") |@|\n      configString("groupSearch")\n  )(LDAPConfig.apply, LDAPConfig.unapply)\n}\n\ncase class LDAPConfig(\n  url: LazyConfigString.Raw,\n  systemUser: LazyConfigString.Raw,\n  systemPassword: LazyConfigString.Raw,\n  userBase: LazyConfigString.Raw,\n  userAttribute: LazyConfigString.Raw,\n  groupBase: LazyConfigString.Raw,\n  groupAttribute: LazyConfigString.Raw,\n  groupSearch: LazyConfigString.Raw\n)\n')))}p.isMDXComponent=!0}}]);