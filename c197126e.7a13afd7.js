(window.webpackJsonp=window.webpackJsonp||[]).push([[39],{106:function(e,n,t){"use strict";t.r(n),t.d(n,"frontMatter",(function(){return i})),t.d(n,"metadata",(function(){return s})),t.d(n,"toc",(function(){return c})),t.d(n,"default",(function(){return m}));var r=t(3),o=t(7),a=(t(0),t(123)),i={slug:"zio-streams-autorecover",title:"Recovery for (JMS) Streams",tags:["ZIO","Streams","JMS"],author:"Andreas Gies",author_url:"https://github.com/atooni"},s={permalink:"/blended-zio/blog/zio-streams-autorecover",source:"@site/blog/2020-10-30-RecoveringStreams.md",description:"Today we are going to explore the ZIO streams API and see how we can create a stream that will will enter a recovery phase in certain error scenarios. We will explore how we can deal with exceptions on the connection level while keeping the stream processing code untouched.",date:"2020-10-30T00:00:00.000Z",tags:[{label:"ZIO",permalink:"/blended-zio/blog/tags/zio"},{label:"Streams",permalink:"/blended-zio/blog/tags/streams"},{label:"JMS",permalink:"/blended-zio/blog/tags/jms"}],title:"Recovery for (JMS) Streams",truncated:!0,prevItem:{title:"Keep alive for JMS connections",permalink:"/blended-zio/blog/zio-jms-keep-alive"},nextItem:{title:"ZIO Streams and JMS",permalink:"/blended-zio/blog/zio-streams-jms"}},c=[{value:"What we want to achieve",id:"what-we-want-to-achieve",children:[]},{value:"A reconnecting wrapper around the JMS Connection factory",id:"a-reconnecting-wrapper-around-the-jms-connection-factory",children:[]},{value:"Creating a recoverable Stream (consume messages)",id:"creating-a-recoverable-stream-consume-messages",children:[{value:"Why a one element buffer ?",id:"why-a-one-element-buffer-",children:[]}]},{value:"Creating a recoverable Sink (send messages)",id:"creating-a-recoverable-sink-send-messages",children:[]},{value:"Sample log",id:"sample-log",children:[]},{value:"Conclusion",id:"conclusion",children:[]},{value:"Next steps",id:"next-steps",children:[]}],l={toc:c};function m(e){var n=e.components,t=Object(o.a)(e,["components"]);return Object(a.b)("wrapper",Object(r.a)({},l,t,{components:n,mdxType:"MDXLayout"}),Object(a.b)("p",null,"Today we are going to explore the ZIO streams API and see how we can create a stream that will will enter a recovery phase in certain error scenarios. We will explore how we can deal with exceptions on the connection level while keeping the stream processing code untouched."),Object(a.b)("h1",{id:"automatically-recover-jms-streams"},"Automatically recover (JMS) streams"),Object(a.b)("p",null,"In my last ",Object(a.b)("a",Object(r.a)({parentName:"p"},{href:"/blended-zio/blog/zio-streams-jms"}),"article")," I have shown how the ZIO stream API allows us to easily create streams for sending or receiving messages via JMS. Within the sample program we have seen that the streams terminate with an exception whenever the underlying JMS API raises encounters an error."),Object(a.b)("p",null,"One of the most common errors is that the connection is lost due to a network error. For long running applications we would like to initiate an automatic reconnect and either create a new stream or recover the existing stream. The advantage of recovering the existing stream is that we do not have to rewire the users of the streams. Any effect using the existing stream will be suspended until the reconnect has happened and then continue."),Object(a.b)("p",null,"In this article I will explore how we ca use the ZIO API to achieve such a transparent reconnect."),Object(a.b)("div",{className:"admonition admonition-info alert alert--info"},Object(a.b)("div",Object(r.a)({parentName:"div"},{className:"admonition-heading"}),Object(a.b)("h5",{parentName:"div"},Object(a.b)("span",Object(r.a)({parentName:"h5"},{className:"admonition-icon"}),Object(a.b)("svg",Object(r.a)({parentName:"span"},{xmlns:"http://www.w3.org/2000/svg",width:"14",height:"16",viewBox:"0 0 14 16"}),Object(a.b)("path",Object(r.a)({parentName:"svg"},{fillRule:"evenodd",d:"M7 2.3c3.14 0 5.7 2.56 5.7 5.7s-2.56 5.7-5.7 5.7A5.71 5.71 0 0 1 1.3 8c0-3.14 2.56-5.7 5.7-5.7zM7 1C3.14 1 0 4.14 0 8s3.14 7 7 7 7-3.14 7-7-3.14-7-7-7zm1 3H6v5h2V4zm0 6H6v2h2v-2z"})))),"info")),Object(a.b)("div",Object(r.a)({parentName:"div"},{className:"admonition-content"}),Object(a.b)("p",{parentName:"div"},"The complete source code used in this article can be found on ",Object(a.b)("a",Object(r.a)({parentName:"p"},{href:"https://github.com/blended-zio/blended-zio/tree/main/blended.zio.streams"}),"github")))),Object(a.b)("h2",{id:"what-we-want-to-achieve"},"What we want to achieve"),Object(a.b)("p",null,"Like in the last article, let's start by looking at a sample program we would like to run:"),Object(a.b)("pre",null,Object(a.b)("code",Object(r.a)({parentName:"pre"},{className:"language-scala"}),'  private val program = for {\n    _         <- putStrLn("Starting JMS Broker") *> ZIO.service[BrokerService]\n    mgr       <- ZIO.service[ZIOJmsConnectionManager.Service]\n    f         <- ZIO.unit.schedule(Schedule.duration(30.seconds)).fork\n    _         <- mgr\n                   .reconnect(\n                     amqCF.connId(clientId),\n                     Some(new Exception("Boom"))\n                   )\n                   .schedule(Schedule.duration(10.seconds))\n                   .fork\n    jmsStream <- recoveringJmsStream(amqCF, clientId, testDest, 2.seconds)\n    jmsSink   <- recoveringJmsSink(amqCF, clientId, testDest, 1.second)\n    consumer  <- jmsStream.foreach(s => putStrLn(s)).fork\n    producer  <- stream.run(jmsSink).fork\n    _         <- f.join >>> consumer.interrupt >>> producer.interrupt\n  } yield ()\n\n')),Object(a.b)("p",null,"There are 2 important differences in comparison to the sample application of the last article:"),Object(a.b)("ol",null,Object(a.b)("li",{parentName:"ol"},"We are issuing a reconnect to the underlying connection factory. This implies that there is some mechanism within the connection factory that controls an automated reconnect."),Object(a.b)("li",{parentName:"ol"},"Rather than creating the JMS stream / sink directly we use an effect that yields a ",Object(a.b)("strong",{parentName:"li"},"factory")," linked to the connection factory which can create a stream or sink for a given destination.")),Object(a.b)("p",null,"When we run this program with the input stream below, we will notice that the output pauses for a couple of seconds when the reconnect is triggered and then continues sending and receiving messages."),Object(a.b)("pre",null,Object(a.b)("code",Object(r.a)({parentName:"pre"},{className:"language-scala"}),"  private val stream: ZStream[ZEnv, Nothing, String] = ZStream\n    .fromSchedule(Schedule.spaced(1000.millis).jittered)\n    .mapM(_ =>\n      currentTime(TimeUnit.MILLISECONDS)\n        .map(sdf.format)\n    )\n")),Object(a.b)("p",null,"Here is an excerpt from the console output:"),Object(a.b)("pre",null,Object(a.b)("code",Object(r.a)({parentName:"pre"},{}),"2020-10-30-07.13.52.817\n2020-10-30-07.13.54.631\n2020-10-30-07.13.54.985  <----- NOTE THE GAP\n2020-10-30-07.13.58.952  <----- NOTE THE GAP\n2020-10-30-07.13.59.095\n2020-10-30-07.13.59.955\n")),Object(a.b)("h2",{id:"a-reconnecting-wrapper-around-the-jms-connection-factory"},"A reconnecting wrapper around the JMS Connection factory"),Object(a.b)("p",null,"Under the covers we use a connection manager which manages named JMS connections and at the moment it guarantees that for a given id only a single physical JMS connections will be established. Under the covers the connection manager delegates all JMS API calls to the methods of ",Object(a.b)("inlineCode",{parentName:"p"},"ConnectionFactory")," within the JMS API. "),Object(a.b)("p",null,"To guarantee that only a single connection can be established, we wrap the actual connect with a Semaphore and return the connection if it already exists, otherwise we create a new connection and store it."),Object(a.b)("pre",null,Object(a.b)("code",Object(r.a)({parentName:"pre"},{className:"language-scala"}),"      private[jms] def connect(\n        cf: JmsConnectionFactory,\n        clientId: String\n      ) = {\n\n        val cid = cf.connId(clientId)\n\n        sem.withPermit(\n          for {\n            con <- for {\n                     cr <- getConnection(cid)\n                     c  <- ZIO.fromOption(cr).orElse(checkedConnect(cf, clientId))\n                   } yield c\n          } yield con\n        )\n      }\n")),Object(a.b)("p",null,"To recover a connection, we perform a JMS close on the existing connect and enter a recovery period. Within that period any execution of the ",Object(a.b)("inlineCode",{parentName:"p"},"connect")," effect will result in a ",Object(a.b)("inlineCode",{parentName:"p"},"JMSException"),"."),Object(a.b)("pre",null,Object(a.b)("code",Object(r.a)({parentName:"pre"},{className:"language-scala"}),'      private def recover(\n        c: JmsConnection,\n        t: Option[Throwable]\n      ) = for {\n        _ <- close(c)\n        _ <- scheduleRecover(c.factory, c.clientId, t)\n      } yield ()\n\n      private def scheduleRecover(\n        cf: JmsConnectionFactory,\n        clientId: String,\n        t: Option[Throwable]\n      ) = {\n\n        val cid = cf.connId(clientId)\n\n        ZIO.ifM(getConnection(cid).map(_.isDefined))(\n          ZIO.unit,\n          for {\n            _ <-\n              log.debug(\n                s"Beginning recovery period for [$cid]" + t.map(c => s" , cause [${c.getMessage}]").getOrElse("")\n              )\n            _ <- recovering.update(r => cid :: r)\n            f <- recovering.update(_.filterNot(_ == cid)).schedule(Schedule.duration(cf.reconnectInterval)).fork\n            _ <- f.join\n            _ <- log.debug(s"Ending recovery period for [$cid]")\n          } yield ()\n        )\n      }\n\n      private def checkedConnect(\n        cf: JmsConnectionFactory,\n        clientId: String\n      ) = {\n\n        val cid = cf.connId(clientId)\n\n        ZIO.ifM(isRecovering(cid))(\n          ZIO.fail(new JMSException(s"Connection factory [$cid] is in recovery")),\n          for {\n            c <- doConnect(cf, clientId)\n          } yield c\n        )\n      }\n')),Object(a.b)("p",null,"Finally, the ",Object(a.b)("inlineCode",{parentName:"p"},"reconnect"),"effect simply triggers the recover if an underlying connection currently exists."),Object(a.b)("pre",null,Object(a.b)("code",Object(r.a)({parentName:"pre"},{className:"language-scala"}),'      private[jms] def reconnect(\n        con: JmsConnection,\n        cause: Option[Throwable]\n      ): ZIO[ZEnv with Logging, JMSException, Unit] = for {\n        _  <- log.debug(s"Reconnecting JMS connection [$con]")\n        cr <- getConnection(con.id)\n        _  <- cr match {\n                case None    => ZIO.unit\n                case Some(c) => recover(c, cause)\n              }\n      } yield ()\n')),Object(a.b)("h2",{id:"creating-a-recoverable-stream-consume-messages"},"Creating a recoverable Stream (consume messages)"),Object(a.b)("p",null,"The idea behind the recovering stream is that we connect to the JMS broker with the given connection factory and then start consuming messages until we hit an exception. Whenever we hit an exception, we catch it and enter a recovery phase. After the recovery phase we will try to reconnect and continue to consume messages."),Object(a.b)("pre",null,Object(a.b)("code",Object(r.a)({parentName:"pre"},{className:"language-scala"}),'  def stream(\n    dest: JmsDestination\n  ) = {\n\n    def consumeUntilException(cons: JmsConsumer) = jmsStream(cons).collect { case tm: TextMessage =>\n      tm.getText()\n    }\n      .foreach(s => buffer.offer(s))\n\n    def consumeForEver: ZIO[ZEnv with Logging with ZIOJmsConnectionManager.ZIOJmsConnectionManager, Nothing, Unit] = {\n      val part = for {\n        _      <- log.debug(s"Trying to recover consumer for [${factory.id}] with destination [$dest]")\n        conMgr <- ZIO.service[ZIOJmsConnectionManager.Service]\n        con    <- conMgr.connect(factory, clientId)\n        _      <- createSession(con).use(jmsSess => createConsumer(jmsSess, dest).use(c => consumeUntilException(c)))\n      } yield ()\n\n      part.catchAll { _ =>\n        for {\n          f <- consumeForEver.schedule(Schedule.duration(retryInterval)).fork\n          _ <- f.join\n        } yield ()\n      }\n    }\n\n    for {\n      _ <- consumeForEver.fork\n      s <- ZIO.succeed(ZStream.repeatEffect(buffer.take))\n    } yield s\n  }\n')),Object(a.b)("p",null,"The idea manifests in ",Object(a.b)("inlineCode",{parentName:"p"},"consumeUntilException")," and ",Object(a.b)("inlineCode",{parentName:"p"},"consumeForEver"),". ",Object(a.b)("inlineCode",{parentName:"p"},"consumeUntilException")," uses the stream we have seen in the last ",Object(a.b)("a",Object(r.a)({parentName:"p"},{href:"/blended-zio/blog/zio-streams-jms#receiving-messages"}),"article"),". It will stick all messages that have been received into a one element buffer which we can use later on to create the final stream visible to the outside world."),Object(a.b)("p",null,Object(a.b)("inlineCode",{parentName:"p"},"consumeForever")," simply creates an effect which will create the JMS connection and then delegate to ",Object(a.b)("inlineCode",{parentName:"p"},"consumeUntilException"),". The we apply the ",Object(a.b)("inlineCode",{parentName:"p"},"catchAll")," operator to that effect where we schedule the next iteration to ",Object(a.b)("inlineCode",{parentName:"p"},"consumeForEver")," after a recovery period."),Object(a.b)("p",null,"The final stream is then created from repeating the ",Object(a.b)("inlineCode",{parentName:"p"},"take")," operation of the buffer while ",Object(a.b)("inlineCode",{parentName:"p"},"consumerForEver")," is executing in it's own fiber."),Object(a.b)("h3",{id:"why-a-one-element-buffer-"},"Why a one element buffer ?"),Object(a.b)("p",null,"One might wonder why I am using a one element buffer. We are operating on JMS and want to make sure that no messages are being lost. As a result, in a real application we have to acknowledge the message to the message broker once we are done with processing it. In case we encounter an exception while processing the message we have several options:"),Object(a.b)("ol",null,Object(a.b)("li",{parentName:"ol"},"We drop the message byt acknowledging even if we could not process it correctly"),Object(a.b)("li",{parentName:"ol"},"We forward the message to another destination such as an error destination or a retry destination and acknowledge it"),Object(a.b)("li",{parentName:"ol"},"We deny the message")),Object(a.b)("p",null,"The last option here is not really part of the JMS API which only has an acknowledge method on the JMS message. What we would do in a real application is use a session with ",Object(a.b)("inlineCode",{parentName:"p"},"CLIENT_ACKNOWLEDGE")," and to deny the message we would close the receiving session. This would automatically mark the message as undelivered in the JMS broker - effectively denying the message. As this would apply to all messages that have been received within the same session and that have not been acknowledged yet, we consume the messages one by one."),Object(a.b)("p",null,"We will explore the error handling further in another post."),Object(a.b)("h2",{id:"creating-a-recoverable-sink-send-messages"},"Creating a recoverable Sink (send messages)"),Object(a.b)("p",null,"The idea behind the recovering sink is pretty much the same as for the recovering stream. The subtle difference is that we do not use the sink we have seen in the last ",Object(a.b)("a",Object(r.a)({parentName:"p"},{href:"/blended-zio/blog/zio-streams-jms"}),"article"),", but a method to send a single message."),Object(a.b)("p",null,"Apart from that, the pattern to create the recoverable sink is the same as for creating the stream."),Object(a.b)("pre",null,Object(a.b)("code",Object(r.a)({parentName:"pre"},{className:"language-scala"}),'  def sink(\n    dest: JmsDestination,\n    retryInterval: Duration\n  ) = {\n\n    def produceOne(p: JmsProducer): ZIO[ZEnv with Logging, JMSException, Unit] = buffer.take.flatMap { s: String =>\n      send(s, p, dest)\n    }\n\n    def produceForever: ZIO[ZEnv with Logging with ZIOJmsConnectionManager.ZIOJmsConnectionManager, Nothing, Unit] = {\n      val part = for {\n        _      <- log.debug(s"Trying to recover producer for [${factory.id}] with destination [$dest]")\n        conMgr <- ZIO.service[ZIOJmsConnectionManager.Service]\n        con    <- conMgr.connect(factory, clientId)\n        _      <- createSession(con).use { jmsSess =>\n                    createProducer(jmsSess).use { p =>\n                      for {\n                        f <- produceOne(p).forever.fork\n                        _ <- f.join\n                      } yield ()\n                    }\n                  }\n      } yield ()\n\n      part.catchAll { _ =>\n        for {\n          f <- produceForever.schedule(Schedule.duration(retryInterval)).fork\n          _ <- f.join\n        } yield ()\n      }\n    }\n\n    for {\n      _ <- produceForever.fork\n      s <- ZIO.succeed(ZSink.foreach(msg => buffer.offer(msg)))\n    } yield s\n  }\n')),Object(a.b)("h2",{id:"sample-log"},"Sample log"),Object(a.b)("p",null,"Below is a log excerpt of the sample app execution. Note the disconnect starting time ",Object(a.b)("inlineCode",{parentName:"p"},"10770"),", the recovery period of the connection and the recurring recovery attempts of the consumer and producer stream until the reconnect has finished and everything can resume from ",Object(a.b)("inlineCode",{parentName:"p"},"16550")," onwards."),Object(a.b)("pre",null,Object(a.b)("code",Object(r.a)({parentName:"pre"},{}),"--- Entries omitted\n2020-10-30-08:11.49.397 |     9458 | DEBUG : Received [Some(ActiveMQTextMessage {commandId = 37, responseRequired = true, messageId = ID:ToonBox-46199-1604041900408-4:1:1:1:16, originalDestination = null, originalTransactionId = null, producerId = ID:ToonBox-46199-1604041900408-4:1:1:1, destination = queue://sample, transactionId = null, expiration = 0, timestamp = 1604041909396, arrival = 0, brokerInTime = 1604041909396, brokerOutTime = 1604041909397, correlationId = null, replyTo = null, persistent = true, type = null, priority = 4, groupID = null, groupSequence = 0, targetConsumerId = null, compressed = false, userID = null, content = null, marshalledProperties = null, dataStructure = null, redeliveryCounter = 0, size = 1070, properties = null, readOnlyProperties = true, readOnlyBody = true, droppable = false, jmsXGroupFirstForConsumer = false, text = 2020-10-30-08.11.49.396})] with [JmsConsumer((amq:amq)(sampleCon)-(S-1604041900731-1)-(C-1)-sample)]\n2020-10-30-08:11.50.005 |    10066 | DEBUG : Message [2020-10-30-08.11.50.004] sent successfully with [JmsProducer((amq:amq)(sampleCon)-(S-1604041900731-2)-P-1)] to [sample]\n2020-10-30-08:11.50.005 |    10066 | DEBUG : Received [Some(ActiveMQTextMessage {commandId = 39, responseRequired = true, messageId = ID:ToonBox-46199-1604041900408-4:1:1:1:17, originalDestination = null, originalTransactionId = null, producerId = ID:ToonBox-46199-1604041900408-4:1:1:1, destination = queue://sample, transactionId = null, expiration = 0, timestamp = 1604041910004, arrival = 0, brokerInTime = 1604041910004, brokerOutTime = 1604041910005, correlationId = null, replyTo = null, persistent = true, type = null, priority = 4, groupID = null, groupSequence = 0, targetConsumerId = null, compressed = false, userID = null, content = null, marshalledProperties = null, dataStructure = null, redeliveryCounter = 0, size = 1070, properties = null, readOnlyProperties = true, readOnlyBody = true, droppable = false, jmsXGroupFirstForConsumer = false, text = 2020-10-30-08.11.50.004})] with [JmsConsumer((amq:amq)(sampleCon)-(S-1604041900731-1)-(C-1)-sample)]\n2020-10-30-08:11.50.684 |    10745 | DEBUG : Message [2020-10-30-08.11.50.683] sent successfully with [JmsProducer((amq:amq)(sampleCon)-(S-1604041900731-2)-P-1)] to [sample]\n2020-10-30-08:11.50.684 |    10745 | DEBUG : Received [Some(ActiveMQTextMessage {commandId = 41, responseRequired = true, messageId = ID:ToonBox-46199-1604041900408-4:1:1:1:18, originalDestination = null, originalTransactionId = null, producerId = ID:ToonBox-46199-1604041900408-4:1:1:1, destination = queue://sample, transactionId = null, expiration = 0, timestamp = 1604041910683, arrival = 0, brokerInTime = 1604041910683, brokerOutTime = 1604041910684, correlationId = null, replyTo = null, persistent = true, type = null, priority = 4, groupID = null, groupSequence = 0, targetConsumerId = null, compressed = false, userID = null, content = null, marshalledProperties = null, dataStructure = null, redeliveryCounter = 0, size = 1070, properties = null, readOnlyProperties = true, readOnlyBody = true, droppable = false, jmsXGroupFirstForConsumer = false, text = 2020-10-30-08.11.50.683})] with [JmsConsumer((amq:amq)(sampleCon)-(S-1604041900731-1)-(C-1)-sample)]\n2020-10-30-08:11.50.709 |    10770 | INFO  : Connector vm://simple stopped\n2020-10-30-08:11.50.710 |    10771 | DEBUG : Closed [((amq:amq)(sampleCon))]\n2020-10-30-08:11.50.717 |    10778 | DEBUG : Beginning recovery period for [(amq:amq)] , cause [Boom]\n2020-10-30-08:11.50.720 |    10781 | WARN  : Error receiving message with [JmsConsumer((amq:amq)(sampleCon)-(S-1604041900731-1)-(C-1)-sample)] : [The Consumer is closed]\n2020-10-30-08:11.50.763 |    10824 | DEBUG : Closing Consumer [JmsConsumer((amq:amq)(sampleCon)-(S-1604041900731-1)-(C-1)-sample)]\n2020-10-30-08:11.50.767 |    10828 | DEBUG : Closing JMS Session [((amq:amq)(sampleCon)-(S-1604041900731-1))]\n2020-10-30-08:11.51.442 |    11503 | WARN  : Error sending message with [JmsProducer((amq:amq)(sampleCon)-(S-1604041900731-2)-P-1)] to [JmsQueue(sample)]: [The Session is closed]\n2020-10-30-08:11.51.451 |    11512 | DEBUG : Closing JMS Producer [JmsProducer((amq:amq)(sampleCon)-(S-1604041900731-2)-P-1)]\n2020-10-30-08:11.51.455 |    11516 | DEBUG : Closing JMS Session [((amq:amq)(sampleCon)-(S-1604041900731-2))]\n2020-10-30-08:11.52.459 |    12520 | DEBUG : Trying to recover producer for [(amq:amq)] with [JmsQueue(sample)]\n2020-10-30-08:11.52.771 |    12832 | DEBUG : Trying to recover consumer for [(amq:amq)] with destination [JmsQueue(sample)]\n2020-10-30-08:11.53.464 |    13525 | DEBUG : Trying to recover producer for [(amq:amq)] with [JmsQueue(sample)]\n2020-10-30-08:11.54.467 |    14528 | DEBUG : Trying to recover producer for [(amq:amq)] with [JmsQueue(sample)]\n2020-10-30-08:11.54.774 |    14835 | DEBUG : Trying to recover consumer for [(amq:amq)] with destination [JmsQueue(sample)]\n2020-10-30-08:11.55.470 |    15531 | DEBUG : Trying to recover producer for [(amq:amq)] with [JmsQueue(sample)]\n2020-10-30-08:11.55.773 |    15834 | DEBUG : Ending recovery period for [(amq:amq)]\n2020-10-30-08:11.56.472 |    16533 | DEBUG : Trying to recover producer for [(amq:amq)] with [JmsQueue(sample)]\n2020-10-30-08:11.56.474 |    16535 | DEBUG : Connecting [(amq:amq)] with clientId [sampleCon]\n2020-10-30-08:11.56.475 |    16536 | INFO  : Connector vm://simple started\n2020-10-30-08:11.56.486 |    16547 | DEBUG : Created [((amq:amq)(sampleCon))]\n2020-10-30-08:11.56.489 |    16550 | DEBUG : Created JMS Producer [JmsProducer((amq:amq)(sampleCon)-(S-1604041916487-1)-P-1)]\n2020-10-30-08:11.56.492 |    16553 | DEBUG : Message [2020-10-30-08.11.51.895] sent successfully with [JmsProducer((amq:amq)(sampleCon)-(S-1604041916487-1)-P-1)] to [sample]\n2020-10-30-08:11.56.493 |    16554 | DEBUG : Message [2020-10-30-08.11.52.295] sent successfully with [JmsProducer((amq:amq)(sampleCon)-(S-1604041916487-1)-P-1)] to [sample]\n2020-10-30-08:11.56.776 |    16837 | DEBUG : Trying to recover consumer for [(amq:amq)] with destination [JmsQueue(sample)]\n2020-10-30-08:11.56.781 |    16842 | DEBUG : Created JMS Consumer [JmsConsumer((amq:amq)(sampleCon)-(S-1604041916777-2)-(C-1)-sample)]\n2020-10-30-08:11.56.782 |    16843 | DEBUG : Received [Some(ActiveMQTextMessage {commandId = 5, responseRequired = true, messageId = ID:ToonBox-46199-1604041900408-4:2:1:1:1, originalDestination = null, originalTransactionId = null, producerId = ID:ToonBox-46199-1604041900408-4:2:1:1, destination = queue://sample, transactionId = null, expiration = 0, timestamp = 1604041916490, arrival = 0, brokerInTime = 1604041916490, brokerOutTime = 1604041916779, correlationId = null, replyTo = null, persistent = true, type = null, priority = 4, groupID = null, groupSequence = 0, targetConsumerId = null, compressed = false, userID = null, content = null, marshalledProperties = null, dataStructure = null, redeliveryCounter = 0, size = 1070, properties = null, readOnlyProperties = true, readOnlyBody = true, droppable = false, jmsXGroupFirstForConsumer = false, text = 2020-10-30-08.11.51.895})] with [JmsConsumer((amq:amq)(sampleCon)-(S-1604041916777-2)-(C-1)-sample)]\n2020-10-30-08:11.56.783 |    16844 | DEBUG : Received [Some(ActiveMQTextMessage {commandId = 6, responseRequired = true, messageId = ID:ToonBox-46199-1604041900408-4:2:1:1:2, originalDestination = null, originalTransactionId = null, producerId = ID:ToonBox-46199-1604041900408-4:2:1:1, destination = queue://sample, transactionId = null, expiration = 0, timestamp = 1604041916492, arrival = 0, brokerInTime = 1604041916493, brokerOutTime = 1604041916780, correlationId = null, replyTo = null, persistent = true, type = null, priority = 4, groupID = null, groupSequence = 0, targetConsumerId = null, compressed = false, userID = null, content = null, marshalledProperties = null, dataStructure = null, redeliveryCounter = 0, size = 1070, properties = null, readOnlyProperties = true, readOnlyBody = true, droppable = false, jmsXGroupFirstForConsumer = false, text = 2020-10-30-08.11.52.295})] with [JmsConsumer((amq:amq)(sampleCon)-(S-1604041916777-2)-(C-1)-sample)]\n2020-10-30-08:11.57.123 |    17184 | DEBUG : Message [2020-10-30-08.11.57.122] sent successfully with [JmsProducer((amq:amq)(sampleCon)-(S-1604041916487-1)-P-1)] to [sample]\n2020-10-30-08:11.57.123 |    17184 | DEBUG : Received [Some(ActiveMQTextMessage {commandId = 11, responseRequired = true, messageId = ID:ToonBox-46199-1604041900408-4:2:1:1:3, originalDestination = null, originalTransactionId = null, producerId = ID:ToonBox-46199-1604041900408-4:2:1:1, destination = queue://sample, transactionId = null, expiration = 0, timestamp = 1604041917122, arrival = 0, brokerInTime = 1604041917122, brokerOutTime = 1604041917123, correlationId = null, replyTo = null, persistent = true, type = null, priority = 4, groupID = null, groupSequence = 0, targetConsumerId = null, compressed = false, userID = null, content = null, marshalledProperties = null, dataStructure = null, redeliveryCounter = 0, size = 1070, properties = null, readOnlyProperties = true, readOnlyBody = true, droppable = false, jmsXGroupFirstForConsumer = false, text = 2020-10-30-08.11.57.122})] with [JmsConsumer((amq:amq)(sampleCon)-(S-1604041916777-2)-(C-1)-sample)]\n--- Entries omitted\n")),Object(a.b)("h2",{id:"conclusion"},"Conclusion"),Object(a.b)("p",null,"With very little code and simple patterns we could create ZIO streams on top of JMS with automatic recovery baked in. Towards the users of the created stream or sink the recovery is completely transparent and from their perspective they are working with normal ",Object(a.b)("inlineCode",{parentName:"p"},"ZStream"),"s or ",Object(a.b)("inlineCode",{parentName:"p"},"ZSink"),"s."),Object(a.b)("h2",{id:"next-steps"},"Next steps"),Object(a.b)("p",null,"The next step is to add a keep alive monitor to an established connection, which will trigger reconnects if a maximum number of keep alive messages have been missed."))}m.isMDXComponent=!0},123:function(e,n,t){"use strict";t.d(n,"a",(function(){return u})),t.d(n,"b",(function(){return h}));var r=t(0),o=t.n(r);function a(e,n,t){return n in e?Object.defineProperty(e,n,{value:t,enumerable:!0,configurable:!0,writable:!0}):e[n]=t,e}function i(e,n){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);n&&(r=r.filter((function(n){return Object.getOwnPropertyDescriptor(e,n).enumerable}))),t.push.apply(t,r)}return t}function s(e){for(var n=1;n<arguments.length;n++){var t=null!=arguments[n]?arguments[n]:{};n%2?i(Object(t),!0).forEach((function(n){a(e,n,t[n])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):i(Object(t)).forEach((function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(t,n))}))}return e}function c(e,n){if(null==e)return{};var t,r,o=function(e,n){if(null==e)return{};var t,r,o={},a=Object.keys(e);for(r=0;r<a.length;r++)t=a[r],n.indexOf(t)>=0||(o[t]=e[t]);return o}(e,n);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);for(r=0;r<a.length;r++)t=a[r],n.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(e,t)&&(o[t]=e[t])}return o}var l=o.a.createContext({}),m=function(e){var n=o.a.useContext(l),t=n;return e&&(t="function"==typeof e?e(n):s(s({},n),e)),t},u=function(e){var n=m(e.components);return o.a.createElement(l.Provider,{value:n},e.children)},d={inlineCode:"code",wrapper:function(e){var n=e.children;return o.a.createElement(o.a.Fragment,{},n)}},p=o.a.forwardRef((function(e,n){var t=e.components,r=e.mdxType,a=e.originalType,i=e.parentName,l=c(e,["components","mdxType","originalType","parentName"]),u=m(t),p=r,h=u["".concat(i,".").concat(p)]||u[p]||d[p]||a;return t?o.a.createElement(h,s(s({ref:n},l),{},{components:t})):o.a.createElement(h,s({ref:n},l))}));function h(e,n){var t=arguments,r=n&&n.mdxType;if("string"==typeof e||r){var a=t.length,i=new Array(a);i[0]=p;var s={};for(var c in n)hasOwnProperty.call(n,c)&&(s[c]=n[c]);s.originalType=e,s.mdxType="string"==typeof e?e:r,i[1]=s;for(var l=2;l<a;l++)i[l]=t[l];return o.a.createElement.apply(null,i)}return o.a.createElement.apply(null,t)}p.displayName="MDXCreateElement"}}]);