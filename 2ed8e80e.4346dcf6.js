(window.webpackJsonp=window.webpackJsonp||[]).push([[16],{118:function(e,a,t){"use strict";t.d(a,"a",(function(){return p})),t.d(a,"b",(function(){return u}));var n=t(0),i=t.n(n);function r(e,a,t){return a in e?Object.defineProperty(e,a,{value:t,enumerable:!0,configurable:!0,writable:!0}):e[a]=t,e}function c(e,a){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(e);a&&(n=n.filter((function(a){return Object.getOwnPropertyDescriptor(e,a).enumerable}))),t.push.apply(t,n)}return t}function s(e){for(var a=1;a<arguments.length;a++){var t=null!=arguments[a]?arguments[a]:{};a%2?c(Object(t),!0).forEach((function(a){r(e,a,t[a])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):c(Object(t)).forEach((function(a){Object.defineProperty(e,a,Object.getOwnPropertyDescriptor(t,a))}))}return e}function o(e,a){if(null==e)return{};var t,n,i=function(e,a){if(null==e)return{};var t,n,i={},r=Object.keys(e);for(n=0;n<r.length;n++)t=r[n],a.indexOf(t)>=0||(i[t]=e[t]);return i}(e,a);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);for(n=0;n<r.length;n++)t=r[n],a.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(e,t)&&(i[t]=e[t])}return i}var l=i.a.createContext({}),b=function(e){var a=i.a.useContext(l),t=a;return e&&(t="function"==typeof e?e(a):s(s({},a),e)),t},p=function(e){var a=b(e.components);return i.a.createElement(l.Provider,{value:a},e.children)},m={inlineCode:"code",wrapper:function(e){var a=e.children;return i.a.createElement(i.a.Fragment,{},a)}},d=i.a.forwardRef((function(e,a){var t=e.components,n=e.mdxType,r=e.originalType,c=e.parentName,l=o(e,["components","mdxType","originalType","parentName"]),p=b(t),d=n,u=p["".concat(c,".").concat(d)]||p[d]||m[d]||r;return t?i.a.createElement(u,s(s({ref:a},l),{},{components:t})):i.a.createElement(u,s({ref:a},l))}));function u(e,a){var t=arguments,n=a&&a.mdxType;if("string"==typeof e||n){var r=t.length,c=new Array(r);c[0]=d;var s={};for(var o in a)hasOwnProperty.call(a,o)&&(s[o]=a[o]);s.originalType=e,s.mdxType="string"==typeof e?e:n,c[1]=s;for(var l=2;l<r;l++)c[l]=t[l];return i.a.createElement.apply(null,c)}return i.a.createElement.apply(null,t)}d.displayName="MDXCreateElement"},83:function(e,a,t){"use strict";t.r(a),t.d(a,"frontMatter",(function(){return c})),t.d(a,"metadata",(function(){return s})),t.d(a,"toc",(function(){return o})),t.d(a,"default",(function(){return b}));var n=t(3),i=t(7),r=(t(0),t(118)),c={id:"mbeanpublisher",title:"MBean Publisher"},s={unversionedId:"jmx/mbeanpublisher",id:"jmx/mbeanpublisher",isDocsHomePage:!1,title:"MBean Publisher",description:"The MBean publisher is used to publish arbitrary case classes as DynamicMBeans via JMX. A generic mapper will examine the structure of the given case class instance and recursively map all attributes to corresponding attributes within th MBean.",source:"@site/docs/jmx/MBeanPublisher.md",slug:"/jmx/mbeanpublisher",permalink:"/blended-zio/docs/jmx/mbeanpublisher",version:"current",sidebar:"someSidebar",previous:{title:"A simple MBean Server Facade",permalink:"/blended-zio/docs/jmx/mbeanserver"},next:{title:"Service Metrics",permalink:"/blended-zio/docs/jmx/servicemetrics"}},o=[{value:"Using the MBean publisher",id:"using-the-mbean-publisher",children:[]},{value:"Implementation details",id:"implementation-details",children:[]}],l={toc:o};function b(e){var a=e.components,t=Object(i.a)(e,["components"]);return Object(r.b)("wrapper",Object(n.a)({},l,t,{components:a,mdxType:"MDXLayout"}),Object(r.b)("p",null,"The MBean publisher is used to publish arbitrary case classes as ",Object(r.b)("inlineCode",{parentName:"p"},"DynamicMBean"),"s via JMX. A generic mapper will examine the structure of the given case class instance and recursively map all attributes to corresponding attributes within th MBean."),Object(r.b)("p",null,"As such the interface definition for the publishing service is:"),Object(r.b)("pre",null,Object(r.b)("code",Object(n.a)({parentName:"pre"},{className:"language-scala"}),"  trait Service {\n\n    /**\n     * Retrieve the list of object names that are currently registered by this service.\n     */\n    def managedNames: ZIO[Any, Nothing, List[String]]\n\n    /**\n     * Create or update the MBean within JMX with the <code>DynamicMBean</code> representation of the given case class instance.\n     */\n    def updateMBean[T <: Product](\n      v: T\n    )(implicit f: T => Nameable[T]): ZIO[Any, MBeanPublishException, Unit]\n\n    /**\n     * Remove the registration from JMX for the object name derived from the given case class.\n     */\n    def removeMBean[T <: Product](v: T)(implicit f: T => Nameable[T]): ZIO[Any, MBeanPublishException, Unit]\n  }\n")),Object(r.b)("h2",{id:"using-the-mbean-publisher"},"Using the MBean publisher"),Object(r.b)("p",null,"The easiest way to use the MBeanPublisher is to make it available through a layer like it is done within the tests:"),Object(r.b)("pre",null,Object(r.b)("code",Object(n.a)({parentName:"pre"},{className:"language-scala"}),"  private val logSlf4j = Slf4jLogger.make((_, message) => message)\n\n  private val mbeanLayer: ZLayer[Any, Nothing, MBeanServerFacade.MBeanServerFacade] =\n    logSlf4j >>> MBeanServerFacade.live\n")),Object(r.b)("p",null,"Then the MBeanPublisher can be used by simply passing a case class to ",Object(r.b)("inlineCode",{parentName:"p"},"updateMBean"),". For now the case class also needs to implement ",Object(r.b)("inlineCode",{parentName:"p"},"Nameable")," so that the proper ",Object(r.b)("inlineCode",{parentName:"p"},"ObjectName")," can be calculated."),Object(r.b)("pre",null,Object(r.b)("code",Object(n.a)({parentName:"pre"},{className:"language-scala"}),'  private val simplePublish = testM("publish a simple case class")(for {\n    pub  <- ZIO.service[ProductMBeanPublisher.Service]\n    fac  <- ZIO.service[MBeanServerFacade.Service]\n    cc   <- ZIO.succeed(Simple("test1", 0, "Hello Jmx"))\n    info <- pub.updateMBean(cc) >>> fac.mbeanInfo(objectName(cc))\n  } yield {\n    val keys = info.attributes.value.keys.toList\n    assert(keys)(contains("counter")) &&\n    assert(keys)(contains("message")) &&\n    assert(keys)(hasSize(equalTo(3))) &&\n    assert(info.attributes.value("counter").value.asInstanceOf[Int])(equalTo(0))\n  })\n')),Object(r.b)("p",null,"In the test case we are also using the ",Object(r.b)("inlineCode",{parentName:"p"},"MBeanServerFacade")," to verify that the ",Object(r.b)("inlineCode",{parentName:"p"},"MBean")," has been published correctly and has the correct values."),Object(r.b)("div",{className:"admonition admonition-note alert alert--secondary"},Object(r.b)("div",Object(n.a)({parentName:"div"},{className:"admonition-heading"}),Object(r.b)("h5",{parentName:"div"},Object(r.b)("span",Object(n.a)({parentName:"h5"},{className:"admonition-icon"}),Object(r.b)("svg",Object(n.a)({parentName:"span"},{xmlns:"http://www.w3.org/2000/svg",width:"14",height:"16",viewBox:"0 0 14 16"}),Object(r.b)("path",Object(n.a)({parentName:"svg"},{fillRule:"evenodd",d:"M6.3 5.69a.942.942 0 0 1-.28-.7c0-.28.09-.52.28-.7.19-.18.42-.28.7-.28.28 0 .52.09.7.28.18.19.28.42.28.7 0 .28-.09.52-.28.7a1 1 0 0 1-.7.3c-.28 0-.52-.11-.7-.3zM8 7.99c-.02-.25-.11-.48-.31-.69-.2-.19-.42-.3-.69-.31H6c-.27.02-.48.13-.69.31-.2.2-.3.44-.31.69h1v3c.02.27.11.5.31.69.2.2.42.31.69.31h1c.27 0 .48-.11.69-.31.2-.19.3-.42.31-.69H8V7.98v.01zM7 2.3c-3.14 0-5.7 2.54-5.7 5.68 0 3.14 2.56 5.7 5.7 5.7s5.7-2.55 5.7-5.7c0-3.15-2.56-5.69-5.7-5.69v.01zM7 .98c3.86 0 7 3.14 7 7s-3.14 7-7 7-7-3.12-7-7 3.14-7 7-7z"})))),"note")),Object(r.b)("div",Object(n.a)({parentName:"div"},{className:"admonition-content"}),Object(r.b)("p",{parentName:"div"},"The implementation keeps track of all instances that have been published. Only the first call to publish will actually register the MBean while\nsubsequent calls will only update the underlying value. The Service makes sure that updates to MBeans are only allowed for MBeans that are based\non the same Class."))),Object(r.b)("h2",{id:"implementation-details"},"Implementation details"),Object(r.b)("p",null,"The service implementation keeps track of the published values in a ",Object(r.b)("inlineCode",{parentName:"p"},"TMap")," with the object name as key and the ",Object(r.b)("inlineCode",{parentName:"p"},"DynamicMBean")," wrapper around the case class."),Object(r.b)("p",null,"To manipulate the ",Object(r.b)("inlineCode",{parentName:"p"},"TMap")," we use some helper methods to either create or update an entry within the ",Object(r.b)("inlineCode",{parentName:"p"},"TMap"),":"),Object(r.b)("pre",null,Object(r.b)("code",Object(n.a)({parentName:"pre"},{className:"language-scala"}),"  private def updateMBean[T <: Product](old: OpenProductMBean, bean: T): STM[Throwable, Unit] =\n    STM.ifM(STM.succeed(old.beanClass.equals(bean.getClass)))(\n      STM.fromTry(Try {\n        val mapped = mapper.mapProduct(bean)\n        old.update(bean.getClass, mapped).get\n      }),\n      STM.fail(new IncompatibleJmxUpdateException(bean.getClass, old.beanClass))\n    )\n\n  private def createMBean[T <: Product](bean: T)(implicit f: T => Nameable[T]): STM[Throwable, Unit] =\n    STM\n      .fromTry(Try {\n        val on: ObjectName = new ObjectName(objectName(bean).objectName)\n\n        try svr.unregisterMBean(on)\n        catch {\n          case _: InstanceNotFoundException => // swallow that exception\n        }\n\n        val mapped = mapper.mapProduct(bean)\n        val b      = new OpenProductMBean(bean.getClass, mapped)\n        svr.registerMBean(b, new ObjectName(objectName(bean).objectName))\n        b\n      })\n      .flatMap { b =>\n        self.beans.put(objectName(bean).objectName, b)\n      }\n\n  private def createOrUpdate[T <: Product](bean: T)(implicit f: T => Nameable[T]): STM[Throwable, Unit] =\n    self.beans.get(objectName(bean).objectName).flatMap {\n      case Some(e) => updateMBean(e, bean)\n      case None    => createMBean(bean)\n    }\n")),Object(r.b)("div",{className:"admonition admonition-caution alert alert--warning"},Object(r.b)("div",Object(n.a)({parentName:"div"},{className:"admonition-heading"}),Object(r.b)("h5",{parentName:"div"},Object(r.b)("span",Object(n.a)({parentName:"h5"},{className:"admonition-icon"}),Object(r.b)("svg",Object(n.a)({parentName:"span"},{xmlns:"http://www.w3.org/2000/svg",width:"16",height:"16",viewBox:"0 0 16 16"}),Object(r.b)("path",Object(n.a)({parentName:"svg"},{fillRule:"evenodd",d:"M8.893 1.5c-.183-.31-.52-.5-.887-.5s-.703.19-.886.5L.138 13.499a.98.98 0 0 0 0 1.001c.193.31.53.501.886.501h13.964c.367 0 .704-.19.877-.5a1.03 1.03 0 0 0 .01-1.002L8.893 1.5zm.133 11.497H6.987v-2.003h2.039v2.003zm0-3.004H6.987V5.987h2.039v4.006z"})))),"caution")),Object(r.b)("div",Object(n.a)({parentName:"div"},{className:"admonition-content"}),Object(r.b)("p",{parentName:"div"},"The implementation uses ",Object(r.b)("a",Object(n.a)({parentName:"p"},{href:"https://zio.dev/docs/datatypes/datatypes_stm"}),"STM")," under the covers. It is important to note that STM code should not include side effecting code that might not be idempotent (such as appending to a file or as in our case register an MBean). The reason for that\nis that the STM code will be retried if any of the STM-values that are being touched by the operation is changed from another fiber."),Object(r.b)("p",{parentName:"div"},"In our case the tests were failing when run in parallel because the registration in JMX might have executed multiple times, which in turn\ncaused a JMX exception."),Object(r.b)("p",{parentName:"div"},"For now we are simply ignoring that specific JMX exception, but a better solution might be looking at another mechanism than TMap to handle that\nscenario."),Object(r.b)("p",{parentName:"div"},"(Also see the ",Object(r.b)("a",Object(n.a)({parentName:"p"},{href:"https://discordapp.com/channels/629491597070827530/630498701860929559/761219670622601277"}),"discussion on Discord"),")"))),Object(r.b)("p",null,"With the helper methods in place, actual service implementation methods is fairly straightforward:"),Object(r.b)("pre",null,Object(r.b)("code",Object(n.a)({parentName:"pre"},{className:"language-scala"}),'  def updateMBean[T <: Product](\n    v: T\n  )(implicit f: T => Nameable[T]): ZIO[Logging, MBeanPublishException, Unit] =\n    createOrUpdate(v).commit.mapError {\n      case mbe: MBeanPublishException                         => mbe\n      case _: javax.management.InstanceAlreadyExistsException => new InstanceAlreadyExistsException[T](v, objectName(v))\n      case t                                                  => new JmxException(t)\n    } <* log.debug(s"updated MBean with name [${objectName(v)}}] to [$v]")\n\n  def removeMBean[T <: Product](v: T)(implicit f: T => Nameable[T]): ZIO[Logging, MBeanPublishException, Unit] =\n    self.beans\n      .get(objectName(v).objectName)\n      .flatMap {\n        case Some(_) =>\n          STM.fromTry(Try {\n            try svr.unregisterMBean(new ObjectName(objectName(v).objectName))\n            catch {\n              case _: InstanceNotFoundException => // swallow that exception as it may occur in STM retries\n            }\n          }) >>> self.beans.delete(objectName(v).objectName)\n        case None    => STM.unit\n      }\n      .commit\n      .mapError {\n        case mbe: MBeanPublishException => mbe\n        case t                          => new JmxException(t)\n      } <* log.debug(s"Removed MBean with name [${objectName(v)}]")\n')))}b.isMDXComponent=!0}}]);